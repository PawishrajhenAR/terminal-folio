const asciiArt = {
  about: `
  █████╗ ██████╗  ██████╗ ██╗   ██╗████████╗
  ██╔══██╗██╔══██╗██╔═══██╗██║   ██║╚══██╔══╝
  ███████║██████╔╝██║   ██║██║   ██║   ██║   
  ██╔══██║██╔══██╗██║   ██║██║   ██║   ██║   
  ██║  ██║██████╔╝╚██████╔╝╚██████╔╝   ██║   
  ╚═╝  ╚═╝╚═════╝  ╚═════╝  ╚═════╝    ╚═╝   
  `,
  projects: `
  ██████╗ ██████╗  ██████╗      ██╗███████╗ ██████╗████████╗███████╗
  ██╔══██╗██╔══██╗██╔═══██╗     ██║██╔════╝██╔════╝╚══██╔══╝██╔════╝
  ██████╔╝██████╔╝██║   ██║     ██║█████╗  ██║        ██║   ███████╗
  ██╔═══╝ ██╔══██╗██║   ██║██   ██║██╔══╝  ██║        ██║   ╚════██║
  ██║     ██║  ██║╚██████╔╝╚█████╔╝███████╗╚██████╗   ██║   ███████║
  ╚═╝     ╚═╝  ╚═╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝   ╚══════╝
  `,
  skills: `
  ███████╗██╗  ██╗██╗██╗     ██╗     ███████╗
  ██╔════╝██║ ██╔╝██║██║     ██║     ██╔════╝
  ███████╗█████╔╝ ██║██║     ██║     ███████╗
  ╚════██║██╔═██╗ ██║██║     ██║     ╚════██║
  ███████║██║  ██╗██║███████╗███████╗███████║
  ╚══════╝╚═╝  ╚═╝╚═╝╚══════╝╚══════╝╚══════╝
  `,
  resume: `
  ██████╗ ███████╗███████╗██╗   ██╗███╗   ███╗███████╗
  ██╔══██╗██╔════╝██╔════╝██║   ██║████╗ ████║██╔════╝
  ██████╔╝█████╗  ███████╗██║   ██║██╔████╔██║█████╗  
  ██╔══██╗██╔══╝  ╚════██║██║   ██║██║╚██╔╝██║██╔══╝  
  ██║  ██║███████╗███████║╚██████╔╝██║ ╚═╝ ██║███████╗
  ╚═╝  ╚═╝╚══════╝╚══════╝ ╚═════╝ ╚═╝     ╚═╝╚══════╝
  `,
  contact: `
  ██████╗ ██████╗ ███╗   ██╗████████╗ █████╗  ██████╗████████╗
  ██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔══██╗██╔════╝╚══██╔══╝
  ██║     ██║   ██║██║╚██╗██║   ██║   ███████║██║        ██║   
  ██║     ██║   ██║██║╚██╗██║   ██║   ██╔══██║██║        ██║   
  ╚██████╗╚██████╔╝██║ ╚████║   ██║   ██║  ██║╚██████╗   ██║   
   ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝   ╚═╝   
  `,
  games: `
  ▄████  ▄▄▄       ███▄ ▄███▓▓█████   ██████ 
 ██▒ ▀█▒▒████▄    ▓██▒▀█▀ ██▒▓█   ▀ ▒██    ▒ 
▒██░▄▄▄░▒██  ▀█▄  ▓██    ▓██░▒███   ░ ▓██▄   
░▓█  ██▓░██▄▄▄▄██ ▒██    ▒██ ▒▓█  ▄   ▒   ██▒
░▒▓███▀▒ ▓█   ▓██▒▒██▒   ░██▒░▒████▒▒██████▒▒
 ░▒   ▒  ▒▒   ▓▒█░░ ▒░   ░  ░░░ ▒░ ░▒ ▒▓▒ ▒ ░
  ░   ░   ▒   ▒▒ ░░  ░      ░ ░ ░  ░░ ░▒  ░ ░
░ ░   ░   ░   ▒   ░      ░      ░   ░  ░  ░  
      ░       ░  ░       ░      ░  ░      ░  
  `,
  research: `
  ██████╗ ███████╗███████╗███████╗ █████╗ ██████╗  ██████╗██╗  ██╗
  ██╔══██╗██╔════╝██╔════╝██╔════╝██╔══██╗██╔══██╗██╔════╝██║  ██║
  ██████╔╝█████╗  ███████╗█████╗  ███████║██████╔╝██║     ███████║
  ██╔══██╗██╔══╝  ╚════██║██╔══╝  ██╔══██║██╔══██╗██║     ██╔══██║
  ██║  ██║███████╗███████║███████╗██║  ██║██║  ██║╚██████╗██║  ██║
  ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝
  `,
};

const projectCards = `
  <div class="terminal-card-grid">
    <!-- Project 1: Multimodal Emotion Classifier -->
    <div class="terminal-card">
      <div class="content">
        <h3>Multimodal Emotion Classifier</h3>
        <p><strong>LLM + CNN + Transformer fusion</strong> for text & image emotion detection. Advanced multimodal AI achieving high-accuracy emotion prediction across diverse input types.</p>
        <a href="https://github.com/Codesaur1618/Multimodal_emotion-Classification_usingLLM" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 2: MaliciousURLNet -->
    <div class="terminal-card">
      <div class="content">
        <h3>MaliciousURLNet</h3>
        <p><strong>CNN-BiLSTM + LLaMA AI</strong> cybersecurity system. Attention-based threat detection with enterprise-grade reporting. Real-time URL analysis for security teams and penetration testers.</p>
        <a href="https://github.com/PawishrajhenAR/MaliciousURLNet" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 3: DermaScan AI -->
    <div class="terminal-card">
      <div class="content">
        <h3>DermaScan AI</h3>
        <p><strong>TensorFlow medical imaging</strong> on HAM10000 dataset. Multi-language dermatological diagnosis with AI-powered explanations for healthcare professionals.</p>
        <a href="https://github.com/PawishrajhenAR/DermaScan-AI" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 4: ShadowNet -->
    <div class="terminal-card">
      <div class="content">
        <h3>ShadowNet</h3>
        <p><strong>Three-stage AI pipeline</strong>: U-Net detection + Latent Diffusion removal + DeepFill v2 refinement. 98% accuracy, 2.8s processing on 1000+ images. Streamlit deployment for professional image enhancement.</p>
        <a href="https://github.com/PawishrajhenAR/Shadow-Removal" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 5: OceanWatch -->
    <div class="terminal-card">
      <div class="content">
        <h3>OceanWatch</h3>
        <p><strong>Oceanographic data analytics</strong> for marine ecosystem monitoring. Real-time environmental threat assessment supporting climate research.</p>
        <a href="https://github.com/PawishrajhenAR/Hybrid-ARIMA-LSTM-Stacked-Ensemble-for-RealTime-Multivariate-Forecasting-of-Ocean-Acidification" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 6: LiverScan-AI -->
    <div class="terminal-card">
      <div class="content">
        <h3>LiverScan-AI</h3>
        <p><strong>Capsule Neural Networks (CapsNet)</strong> for liver tumor segmentation. Web-based diagnostic tool for healthcare professionals and researchers.</p>
        <a href="https://github.com/PawishrajhenAR/LiverScan-AI" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 7: SightSpeak -->
    <div class="terminal-card">
      <div class="content">
        <h3>SightSpeak</h3>
        <p><strong>YOLOv8 + LLaMA3.2</strong> assistive technology. AI-powered navigation aid enhancing independence for visually impaired users.</p>
        <a href="https://github.com/PawishrajhenAR/SightSpeak" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 8: BlockVote -->
    <div class="terminal-card">
      <div class="content">
        <h3>BlockVote</h3>
        <p><strong>Ethereum smart contracts + React TypeScript frontend</strong>. Decentralized voting with MetaMask integration and immutable transparency.</p>
        <a href="https://github.com/PawishrajhenAR/BlockVote" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 9: RAG Chat Assistant -->
    <div class="terminal-card">
      <div class="content">
        <h3>RAG Chat Assistant</h3>
        <p><strong>Ollama Phi3 + FAISS + Sentence Transformers</strong> document intelligence system. Streamlit-powered conversational AI with source citations and context-aware responses.</p>
        <a href="https://github.com/PawishrajhenAR/RAG-DocChatApp" target="_blank" class="github-link">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.6.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
        </a>
      </div>
    </div>

    <!-- Project 10: ASCII Art Card -->
    <div class="terminal-card">
      <div class="content" style="display:flex;align-items:center;justify-content:center;min-height:160px;">
        <pre class="ascii-art" style="font-size:1.15em;line-height:1.1;text-align:center;margin:0;">

█▓██▄────────────█
█▓▓░▀▄▀░░░░░░░░░░█
█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
█────────────────█

        </pre>
      </div>
    </div>
  </div>
`;

const contactForm = `
  <div class="contact-section">
    <span style="color:var(--accent)">Let's Connect!</span><br><br>
    
    <span style="color:var(--info)">Name:</span><br>
    <div id="contact-name" class="contact-field"></div><br>
    
    <span style="color:var(--info)">Mail ID:</span><br>
    <div id="contact-email" class="contact-field"></div><br>
    
    <span style="color:var(--info)">Message:</span><br>
    <div id="contact-message" class="contact-field"></div><br>
    
    <form id="contactForm" style="display:inline;">
      <button type="submit" class="send-btn-card">SEND MESSAGE</button>
    </form>
  </div>
`;


const researchSection = `
  <div class="research-flex" style="display:flex;align-items:flex-start;gap:32px;max-width:900px;">
    <div class="research-text" style="flex:1;min-width:0;">
      <!-- TYPING EFFECT TARGET: research-text-content -->
      <span id="research-text-content"></span>
      <button id="view-paper-btn" class="send-btn-card" style="margin-top:12px;">View Paper</button>
    </div>
    <div class="research-ascii" style="flex:0 0 260px;max-width:260px;overflow-x:auto;display:var(--ascii-display, flex);">
      <pre id="research-ascii-art" style="color:var(--accent);font-size:0.95em;line-height:1.1;white-space:pre;word-break:break-all;margin:0;">





            ─────▀▄▀─────▄─────▄
            ──▄███████▄──▀██▄██▀
            ▄█████▀█████▄──▄█
            ███████▀████████▀
            ─▄▄▄▄▄▄███████▀
      </pre>
    </div>
  </div>
`;

const sections = {
  about: `<div class="about-flex" style="display:flex;align-items:flex-start;gap:32px;max-width:900px;">
    <div class="about-text" style="flex:1;min-width:0;">
      <!-- TYPING EFFECT TARGET: about-text-content -->
      <span id="about-text-content"></span>
    </div>
    <div class="about-ascii" style="flex:0 0 260px;max-width:260px;overflow-x:auto;display:var(--ascii-display, flex);">
      <pre id="about-cat-ascii" style="color:var(--accent);font-size:0.95em;line-height:1.1;white-space:pre;word-break:break-all;margin:0;">
              _                       
             \\ \`*-.                   
              )  _\`-.                
             .  : \`. .               
             : _   '  \\              
             ; *\` _.   \`*-._         
             \`-.-'          \`-.      
               ;       \`       \`.    
               :.       .        \\   
               . \\  .   :   .-'   .        |~|
               '  \`+.;  ;  '      :       : :
               :  '  |    ;       ;-.     . :
               ; '   : :\`-:     _.\`* ; '':
       [paw] .*' /  .*' ; .*\`- +'  \`*'.
              \`*-*   \`*-*  \`*-*'       

      </pre>
    </div>
  </div>`,
  projects: projectCards,
  skills: `<div class="skills-fade-in"><div class="skills-flex" style="display:flex;align-items:center;gap:32px;max-width:1100px;">
    <div class="skills-table" style="flex:1;min-width:0;">
      <table style="margin:0;width:100%;max-width:900px;border-collapse:separate;border-spacing:0 16px;font-size:1.12em;">
        <thead>
          <tr style="background:rgba(255,255,255,0.03);">
            <th style="width:260px;text-align:left;padding:14px 20px;color:var(--info);font-size:1.18em;border-bottom:2.5px solid var(--card-border);">Category</th>
            <th style="text-align:left;padding:14px 20px;color:var(--info);font-size:1.18em;border-bottom:2.5px solid var(--card-border);">Skills</th>
          </tr>
        </thead>
        <tbody>
          <tr style="background:rgba(255,255,255,0.04);border-radius:8px;">
            <td style="padding:14px 20px;font-weight:bold;vertical-align:top;color:var(--info);">Programming Languages</td>
            <td style="padding:14px 20px;color:var(--accent);">Python, C, Java, HTML/CSS, JavaScript, SQL</td>
          </tr>
          <tr style="background:rgba(255,255,255,0.04);border-radius:8px;">
            <td style="padding:14px 20px;font-weight:bold;vertical-align:top;color:var(--info);">Frameworks</td>
            <td style="padding:14px 20px;color:var(--accent);">OpenCV, MediaPipe, YOLO, Keras, TensorFlow, PyTorch, Flask, Node.js, FastAPI, Streamlit, Tkinter, DQN, REINFORCE, PPO, Q-Learning, Vosk (Speech Recognition)</td>
          </tr>
          <tr style="background:rgba(255,255,255,0.04);border-radius:8px;">
            <td style="padding:14px 20px;font-weight:bold;vertical-align:top;color:var(--info);">Developer Tools</td>
            <td style="padding:14px 20px;color:var(--accent);">Git, Docker, Google Cloud Platform (GCP), PyCharm, Jupyter Notebook, Anaconda, Firebase, MySQL, Supabase</td>
          </tr>
          <tr style="background:rgba(255,255,255,0.04);border-radius:8px;">
            <td style="padding:14px 20px;font-weight:bold;vertical-align:top;color:var(--info);">Libraries</td>
            <td style="padding:14px 20px;color:var(--accent);">Pandas, NumPy, Matplotlib, Scikit-learn, Web3.js, Seaborn, Gym (OpenAI), Transformers (Hugging Face), XGBoost, RAPIDS (cuDF, cuML, cuGraph), Dask</td>
          </tr>
          <tr style="background:rgba(255,255,255,0.04);border-radius:8px;">
            <td style="padding:14px 20px;font-weight:bold;vertical-align:top;color:var(--info);">Other Tech Skills</td>
            <td style="padding:14px 20px;color:var(--accent);">Natural Language Processing (NLP), Reinforcement Learning, Blockchain Development, Model Optimization, Prompt Engineering, Agentic AI, GPU-Accelerated Computing,Retrieval-Augmented Generation (RAG)</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="skills-ascii" style="flex:0 0 260px;max-width:260px;overflow-x:auto;display:var(--ascii-display, flex);">
      <pre id="skills-dog-ascii" style="color:var(--accent);font-size:1.00em;line-height:1.1;white-space:pre;word-break:break-all;margin:0;">
      ─▄▀─▄▀
      ──▀──▀
      █▀▀▀▀▀█▄
      █░░░░░█─█
      ▀▄▄▄▄▄▀▀
      [coffee]
    </pre>
    </div>
  </div></div>`,
  resume: `
    <div id="resume-section-message" style="margin-bottom: 0.5em; color:var(--accent);">For details on certifications and achievements, please refer to the full resume :</div>
    <button id="view-resume-btn" class="send-btn-card" style="margin-top:0;">View Resume</button>
  `,
  contact: contactForm,
  games: `Check out my coding games, open source, and more fun things here!`,
  research: researchSection,
};

const helpText = `<span style="color:var(--accent)">Available commands:\nabout\nskills\nprojects\nresearch\nresume\ncontact\ngames\nrun --all\nclear\ntheme\nhelp</span>`;

const terminalOutput = document.getElementById('terminal-output');
const terminalInput = document.getElementById('terminal-input');
let history = [];
let historyIndex = 0;

let contactMessageSent = false;
let projectCardsAnimated = false;
let runAllActive = false;
let lastTypedCommand = '';

const terminalPromptStr = 'pawish@terminal:~$';
const terminalPromptSpan = document.getElementById('terminal-prompt');
terminalPromptSpan.innerHTML = `<span style=\"color:var(--prompt);font-weight:bold;font-family:monospace;\">${terminalPromptStr}</span> `;

// Add this after the definition of terminalPromptSpan and before theme switching logic
let lastSectionCommand = 'about'; // Track last shown section/command

// Listen for theme changes and re-render the last section/command
window.addEventListener('themechange', () => {
  // Find all ASCII art spans in the terminal output and update their color
  const asciiSpans = terminalOutput.querySelectorAll('span[data-ascii-art]');
  asciiSpans.forEach(span => {
    span.style.color = getAsciiArtColor();
  });
});

// THEME SWITCHER
const themes = {
  dark: {
    '--bg': '#18181a',
    '--fg': '#e0e0e0',
    '--terminal-bg': '#23272e',
    '--prompt': '#7fffd4',
    '--accent': '#ffb86c',
    '--header-bg': '#18181a',
    '--card-border': '#ffb86c',
    '--card-shadow': '#000a',
    '--card-hover': '#ff6f3c',
    '--card-hover-shadow': '#ff6f3c99',
    '--card-hover-border': '#ff6f3c',
    '--title': '#783286',
    '--hacker': 'false',
    '--info': '#7fffd4',
  },
  light: {
    '--bg': '#fff',
    '--fg': '#23272e',
    '--terminal-bg': '#f5f5f5',
    '--prompt': '#783286',
    '--accent': '#ffb86c',
    '--header-bg': '#e0e0e0',
    '--card-border': '#783286',
    '--card-shadow': '#0001',
    '--card-hover': '#ffb86c',
    '--card-hover-shadow': '#ffb86c33',
    '--card-hover-border': '#ffb86c',
    '--title': '#23272e',
    '--hacker': 'false',
    '--info': '#2563eb',
  },
  hacker: {
    '--bg': '#000',
    '--fg': '#39ff14',
    '--terminal-bg': '#000',
    '--prompt': '#39ff14',
    '--accent': '#39ff14',
    '--header-bg': '#000',
    '--card-border': '#39ff14',
    '--card-shadow': '#003a',
    '--card-hover': '#39ff14',
    '--card-hover-shadow': '#39ff1499',
    '--card-hover-border': '#39ff14',
    '--title': '#39ff14',
    '--hacker': 'true',
    '--info': '#7fffd4',
  }
};

function getAsciiArtColor() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) {
    return '#39ff14'; // green for hacker
  }
  return '#ff6f3c'; // orange for all other themes
}

function updateAsciiArtColor() {
  // Main section ASCII art in terminal output
  const asciiSpans = document.querySelectorAll('#terminal-output span[data-ascii-art], #terminal-output > pre, #terminal-output > div > pre');
  asciiSpans.forEach(element => {
    element.style.setProperty('color', getAsciiArtColor(), 'important');
  });
  // Small ASCII art in project cards
  const cardAscii = document.querySelectorAll('.terminal-card pre.ascii-art');
  cardAscii.forEach(element => {
    element.style.setProperty('color', getComputedStyle(document.documentElement).getPropertyValue('--fg').trim(), 'important');
  });
}

function applyTheme(theme) {
  const root = document.documentElement;
  const t = themes[theme] || themes.dark;
  
  // Apply all theme variables
  Object.entries(t).forEach(([k, v]) => root.style.setProperty(k, v));
  
  // Special hacker font effect
  if (t['--hacker'] === 'true') {
    root.classList.add('hacker-theme');
  } else {
    root.classList.remove('hacker-theme');
  }
  
  // Force a reflow to ensure styles are applied
  void root.offsetHeight;
  
  // Update ASCII art color after a small delay to ensure theme is fully applied
  setTimeout(updateAsciiArtColor, 10);
  
  // Notify games and other components
  const event = new Event('themechange');
  window.dispatchEvent(event);
}

function saveTheme(theme) {
  localStorage.setItem('portfolio_theme', theme);
}

function loadTheme() {
  const t = localStorage.getItem('portfolio_theme');
  if (t && themes[t]) applyTheme(t);
  else applyTheme('dark');
}

// Load the saved theme
loadTheme();

// Update ASCII art color when the page loads
if (document.readyState === 'complete') {
  updateAsciiArtColor();
} else {
  window.addEventListener('load', updateAsciiArtColor);
}

// Update ASCII art color when theme changes
window.addEventListener('themechange', updateAsciiArtColor);

// Also update when the projects section is shown
document.addEventListener('click', function(e) {
  if (e.target && e.target.textContent.trim().toLowerCase() === 'projects') {
    setTimeout(updateAsciiArtColor, 100);
  }
});

function printToTerminal(text, typing = false) {
  // Special handling for about section two-column typing effect
  if (text === sections.about) {
    // Create a container div and set innerHTML to the about section
    const container = document.createElement('div');
    container.innerHTML = sections.about;
    // Get the about text content span
    const aboutTextSpan = container.querySelector('#about-text-content');
    // The text to type (the actual about text)
    const aboutText = `<span style="color:var(--accent)"><b>I'm Pawishrajhen</b>, a curious and hands-on developer with a strong foundation in <b>AI</b>, full-stack development, and systems thinking.<br><br>I've built and contributed to intelligent applications using technologies like <b>Python</b>, <b>TensorFlow</b>, and <b>Streamlit</b>, while also exploring agentic workflows, prompt engineering, and document-based Q&amp;A systems. My recent work spans <b>reinforcement learning models</b>, <b>GPU-accelerated computing</b>, and <b>speech-interactive tools</b> powered by real-time document processing.<br><br>Outside of development, I've co-authored a published research paper on <b>ocean acidification and ecosystem impact</b>, reflecting my commitment to solving real-world problems through data and science. I enjoy taking on complex challenges—whether it's automating resume-job matching, building privacy-first document agents, or designing responsive frontends with seamless user interaction.<br><br><i>I believe in continuous learning, building with intent, and staying grounded in both research and product thinking.</i></span>`;
    // Add the container to the terminal output
    terminalOutput.appendChild(container);
    // Typing effect for about text only
    if (typing) {
      let i = 0;
      return new Promise(resolve => {
        function typeNext() {
          let nextChar = aboutText.slice(0, i);
          aboutTextSpan.innerHTML = nextChar;
          scrollTerminalToBottom();
          if (i <= aboutText.length) {
            i++;
            setTimeout(typeNext, 2);
          } else {
            resolve();
          }
        }
        typeNext();
      });
    } else {
      aboutTextSpan.innerHTML = aboutText;
      scrollTerminalToBottom();
      return Promise.resolve();
    }
    scrollTerminalToBottom();
    return Promise.resolve();
  }
  // Special handling for research section two-column typing effect
  if (text === sections.research) {
    // Create a container div and set innerHTML to the research section
    const container = document.createElement('div');
    container.innerHTML = sections.research;
    // Get the research text content span
    const researchTextSpan = container.querySelector('#research-text-content');
    // The text to type (the actual research text)
    const researchText = `<span style=\"color:var(--accent)\"><b>Hybrid Forecasting Framework for Ocean Acidification and Hypoxia</b><br><b>Role:</b> Research Lead<br><b>Tools:</b> ARIMA, LSTM, Python, GLODAP, SOCAT, IoT, Geospatial Dashboard<br><br>Developed a real-time multivariate forecasting system for predicting ocean acidification and hypoxic events in coastal regions using a hybrid ARIMA-LSTM layered stack. This ensemble model combines:<br>- ARIMA for statistical time series forecasting<br>- LSTM for modeling complex, nonlinear patterns<br><br>The model was trained on historical datasets (GLODAP, SOCAT) and real-time IoT sensor data to predict critical oceanographic indicators such as pH, dissolved oxygen, and dissolved inorganic carbon.<br><br>The results were presented through an interactive geospatial dashboard to support decision-making for environmental monitoring and intervention.<br><br>The proposed hybrid approach outperformed standalone models in prediction accuracy and contributes to scalable, sustainable marine ecosystem management, aligning with UN Sustainable Development Goals 13 (Climate Action) and 14 (Life Below Water).</span>`;
    // Add the container to the terminal output
    terminalOutput.appendChild(container);
    // Typing effect for research text only
    if (typing) {
      let i = 0;
      return new Promise(resolve => {
        function typeNext() {
          let nextChar = researchText.slice(0, i);
          researchTextSpan.innerHTML = nextChar;
          scrollTerminalToBottom();
          if (i <= researchText.length) {
            i++;
            setTimeout(typeNext, 2);
          } else {
            // Always ensure the View Paper button is present
            let btn = container.querySelector('#view-paper-btn');
            if (!btn) {
              btn = document.createElement('button');
              btn.id = 'view-paper-btn';
              btn.className = 'send-btn-card';
              btn.style.marginTop = '12px';
              btn.textContent = 'View Paper';
              researchTextSpan.parentNode.appendChild(btn);
            }
            resolve();
          }
        }
        typeNext();
      });
    } else {
      researchTextSpan.innerHTML = researchText;
      // Always ensure the View Paper button is present
      let btn = container.querySelector('#view-paper-btn');
      if (!btn) {
        btn = document.createElement('button');
        btn.id = 'view-paper-btn';
        btn.className = 'send-btn-card';
        btn.style.marginTop = '12px';
        btn.textContent = 'View Paper';
        researchTextSpan.parentNode.appendChild(btn);
      }
      scrollTerminalToBottom();
      return Promise.resolve();
    }
    scrollTerminalToBottom();
    return Promise.resolve();
  }
  // Detect if this is ASCII art (used for section headers)
  if (text.startsWith('<span style="color:') && text.includes('data-ascii-art')) {
    terminalOutput.innerHTML += text + '\n';
    scrollTerminalToBottom();
    return Promise.resolve();
  }
  // If this is an ASCII art header, add the data-ascii-art attribute
  if (text.startsWith('<span style="color:') && text.includes('████')) {
    text = text.replace('<span style="color:', '<span data-ascii-art style="color:');
  }
  if (!typing) {
    terminalOutput.innerHTML += text + '\n';
    scrollTerminalToBottom();
    return Promise.resolve();
  }
  let i = 0;
  const span = document.createElement('span');
  span.className = 'typing-effect';
  terminalOutput.appendChild(span);
  return new Promise(resolve => {
    function typeNext() {
      if (text.includes('<') && text.includes('>')) {
        span.innerHTML = text;
        span.style.borderRight = 'none';
        terminalOutput.appendChild(document.createElement('br'));
        scrollTerminalToBottom();
        resolve();
        return;
      }
      span.textContent = text.slice(0, i);
      scrollTerminalToBottom();
      if (i <= text.length) {
        i++;
        setTimeout(typeNext, 18);
      } else {
        span.style.borderRight = 'none';
        terminalOutput.appendChild(document.createElement('br'));
        scrollTerminalToBottom();
        resolve();
      }
    }
    typeNext();
  });
}

function scrollTerminalToBottom() {
  // Always scroll to bottom when called, regardless of contactMode
  // This ensures the terminal scrolls down when contact fields are focused
  terminalOutput.scrollTop = terminalOutput.scrollHeight;
  document.querySelector('.terminal-inner').scrollTop = document.querySelector('.terminal-inner').scrollHeight;
}

// --- CONTACT SECTION STATE ---
let contactMode = false;
let contactStep = 0;
let contactData = { name: '', email: '', message: '' };
let editingContact = false;
let gameMode = false;
let currentGame = '';
let snakeGameActive = false;
let snakeGame = null;
let snakeOverlay = null;
let tetrisGameActive = false;
let tetrisGame = null;
let tetrisOverlay = null;

function promptContactField() {
  if (contactStep === 0) {
    printToTerminal('<span style="color:var(--info)">Enter your name:</span> <span style="color:var(--accent)">(or type <b>cancel</b> to exit)</span>', true);
    // Add focus event listener to the name field
    setTimeout(() => {
      const nameField = document.getElementById('contact-name');
      if (nameField) {
        nameField.focus();
        nameField.addEventListener('focus', scrollTerminalToBottom);
      }
      scrollTerminalToBottom();
    }, 10);
  } else if (contactStep === 1) {
    printToTerminal('<span style="color:var(--info)">Enter your mail id:</span> <span style="color:var(--accent)">(or type <b>cancel</b> to exit)</span>', true);
    // Add focus event listener to the email field
    setTimeout(() => {
      const emailField = document.getElementById('contact-email');
      if (emailField) {
        emailField.focus();
        emailField.addEventListener('focus', scrollTerminalToBottom);
      }
      scrollTerminalToBottom();
    }, 10);
  } else if (contactStep === 2) {
    printToTerminal('<span style="color:var(--info)">Enter your message:</span> <span style="color:var(--accent)">(or type <b>cancel</b> to exit)</span>', true);
    // Add focus event listener to the message field
    setTimeout(() => {
      const messageField = document.getElementById('contact-message');
      if (messageField) {
        messageField.focus();
        messageField.addEventListener('focus', scrollTerminalToBottom);
      }
      scrollTerminalToBottom();
    }, 10);
  } else if (contactStep === 3) {
    // Show summary and SEND/EDIT buttons
    printToTerminal('<br><span style="color:var(--accent)">Summary:</span>', false);
    printToTerminal(`<span style=\"color:var(--info)\">Name:</span> <span style=\"color:var(--accent)\">${contactData.name}</span>`, false);
    printToTerminal(`<span style=\"color:var(--info)\">Mail ID:</span> <span style=\"color:var(--accent)\">${contactData.email}</span>`, false);
    printToTerminal(`<span style=\"color:var(--info)\">Message:</span> <span style=\"color:var(--accent)\">${contactData.message}</span>`, false);
    printToTerminal('<form id="contactForm" style="display:inline;"><button type="submit" class="send-btn-card">SEND MESSAGE</button><button type="button" id="editContactBtn" class="send-btn-card" style="margin-left:10px;">EDIT</button></form>', false);
    setTimeout(scrollTerminalToBottom, 10);
  }
}

document.addEventListener('click', function(e) {
  if (e.target && e.target.id === 'editContactBtn') {
    if (contactMessageSent) {
      printToTerminal('<span style="color:var(--ff5555)">Message already sent — editing is disabled.</span>', true);
      return;
    }
    editingContact = true;
    contactStep = 0;
    promptContactField();
  }
});

document.addEventListener('submit', function(e) {
  if (e.target.id === 'contactForm') {
    e.preventDefault();
    if (!contactData.name || !contactData.email || !contactData.message) {
      printToTerminal('<span style="color:var(--ff5555)">Error: Please fill in all fields</span>', true);
      return;
    }
    printToTerminal('<span style="color:var(--info)">$ contact form submitted</span>');
    printToTerminal(`<span style="color:var(--50fa7b)">✓ Message sent successfully!</span>`, true);
    printToTerminal(`<span style="color:var(--ffb86c)">From: ${contactData.name} (${contactData.email})</span>`, true);
    printToTerminal(`<span style="color:var(--ffb86c)">Message: ${contactData.message}</span>`, true);
    
    // Format email with better structure
    const subject = `Portfolio Contact: ${contactData.name} - ${new Date().toLocaleDateString()}`;
    const body = `Hello Pawish,

You've received a new message from your portfolio website:

---
Name: ${contactData.name}
Email: ${contactData.email}
Date: ${new Date().toLocaleString()}
---

Message:
${contactData.message}

---
This message was sent via your portfolio website.
`;

    // Open mail app with prefilled data
    setTimeout(() => {
      const mailto = `mailto:pawishgpt@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      window.location.href = mailto;
    }, 500);
    contactMode = false;
    contactStep = 0;
    contactData = { name: '', email: '', message: '' };
    editingContact = false;
    contactMessageSent = true;
    terminalInput.classList.remove('hidden');
  }
});

// --- FUNNY FAKE TERMINAL COMMANDS ---
const fakeCommands = {
  'sudo rm -rf /': async function() {
    printToTerminal('<span style="#ff5555">System self-destruct initiated...</span>', true);
    await delay(1200);
    printToTerminal('<span style="#ffb86c">Just kidding! Your files are safe. </span>', true);
  },
  'hack nasa': async function() {
    printToTerminal('<span style="#7fffd4">Launching space invader module...</span>', true);
    await delay(1000);
    printToTerminal('<span style="#ff5555">Access denied, Agent!</span>', true);
  },
  'nuke --world': async function() {
    printToTerminal('<span style="#ffb86c">Preparing world domination...</span>', true);
    await delay(1000);
    printToTerminal('<span style="#ff5555">Connection timeout! Try again after apocalypse.</span>', true);
  },
  'format c:': async function() {
    printToTerminal('<span style="#7fffd4">Formatting your conscience...</span>', true);
    await delay(1000);
    printToTerminal('<span style="#50fa7b">Clean!</span>', true);
  },
  'run away': async function() {
    printToTerminal('<span style="#ffb86c">Escaping reality...</span>', true);
    await delay(1200);
    printToTerminal('<span style="#ff5555">Error: Reality is non-escapable.</span>', true);
  },
  'install coffee': async function() {
    printToTerminal('<span style="#ffb86c">Installing coffee...</span>', true);
    await delay(1000);
    printToTerminal('<span style="#50fa7b">Coffee installed successfully. Productivity level: 9000.</span>', true);
  },
  'git blame life': async function() {
    printToTerminal('<span style="#ffb86c">It\'s probably your fault.</span>', true);
  },
  'cd /love/life': async function() {
    printToTerminal('<span style="#ff5555">No such file or directory.</span>', true);
  },
  'make me a sandwich': async function() {
    printToTerminal('<span style="#ffb86c">What? Make it yourself!</span>', true);
  },
  'sudo make me a sandwich': async function() {
    printToTerminal('<span style="#50fa7b">Okay. Sandwich granted.</span>', true);
  },
};

function handleCommand(cmd) {
  const command = cmd.trim().toLowerCase();
  lastTypedCommand = command;
  // --- FAKE COMMANDS HANDLER ---
  if (Object.keys(fakeCommands).includes(cmd.trim())) {
    fakeCommands[cmd.trim()]();
    return;
  }
  if (snakeGameActive) {
    if (command === 'stop') {
      stopSnakeGame(true);
      return;
    }
    // Ignore other commands while game is active
    return;
  }
  if (tetrisGameActive) {
    if (command === 'stop') {
      stopTetrisGame(true);
      return;
    }
    // Ignore other commands while game is active
    return;
  }
  if (gameMode) {
    if (command === 'stop') {
      forceClearAllGames();
      printToTerminal('<span style="color:var(--ffb86c)">Exiting game mode. Returning to main portfolio...</span>', true);
      gameMode = false;
      currentGame = '';
      printToTerminal('<span style="color:var(--info)">Type <b>help</b> to see available commands.</span>');
      return;
    }
    if (['snake','tetris','2048','whack'].includes(command)) {
      if (command === 'snake') {
        startSnakeGame();
        return;
      }
      if (command === 'tetris') {
        startTetrisGame();
        return;
      }
      if (command === '2048') {
        start2048Game();
        return;
      }
      if (command === 'whack') {
        startWhackAMoleGame();
        return;
      }
      // Placeholder for other games
      currentGame = command;
      printToTerminal(`<span style=\"color:var(--ffb86c)\">Starting ${command}... (Type <b>stop</b> to exit game mode.)</span>`, true);
      return;
    }
    printToTerminal('<span style="color:var(--ff5555)">Unknown game command. Type <b>stop</b> to exit game mode.</span>', true);
    return;
  }
  if (command === 'help') {
    printToTerminal(helpText, true);
    return;
  }
  if (asciiArt[command] && sections[command]) {
    lastSectionCommand = command;
    // Only print ASCII art for sections that have it and are not 'projects' or 'skills'
    if (command !== 'projects' && command !== 'skills') {
      if (command === 'resume') {
        // Mobile: show section name instead of ASCII art
        if (isMobile) {
          printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">${command}</span>`);
        } else {
          printToTerminal(`<span style=\"color:${getAsciiArtColor()}\" data-ascii-art>${asciiArt.resume}</span>`);
        }
        // Typing effect for resume section message
        const resumeMessage = 'For details on certifications and achievements, please refer to the full resume :';
        const container = document.createElement('div');
        container.style.marginBottom = '0.5em';
        container.style.color = 'var(--accent)';
        container.style.fontFamily = 'inherit';
        container.style.fontSize = '1em';
        container.id = 'resume-section-message';
        terminalOutput.appendChild(container);
        let i = 0;
        function typeNext() {
          container.textContent = resumeMessage.slice(0, i);
          scrollTerminalToBottom();
          if (i <= resumeMessage.length) {
            i++;
            setTimeout(typeNext, 18);
          } else {
            // After typing, append the button inline
            const btn = document.createElement('button');
            btn.id = 'view-resume-btn';
            btn.className = 'send-btn-card';
            btn.style.marginLeft = '16px';
            btn.style.verticalAlign = 'middle';
            btn.textContent = 'View Resume';
            container.appendChild(btn);
            setTimeout(resolve, typing ? 1500 : 2000);
          }
        }
        typeNext();
        return;
      } else if (command === 'research') {
        // Mobile: show section name instead of ASCII art
        if (isMobile) {
          printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">${command}</span>`);
        } else {
          printToTerminal(`<span style=\"color:${getAsciiArtColor()}\" data-ascii-art>${asciiArt.research}</span>`);
        }
        printToTerminal(sections[command], true);
        return;
      } else {
        // Mobile: show section name instead of ASCII art
        if (isMobile) {
          printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">${command}</span>`);
        } else {
          printToTerminal(`<span style=\"color:${getAsciiArtColor()}\" data-ascii-art>${asciiArt[command]}</span>`);
        }
      }
    }
    if (command === 'contact') {
      contactMode = true;
      contactStep = 0;
      contactData = { name: '', email: '', message: '' };
      contactMessageSent = false;
      terminalInput.classList.remove('hidden');
      promptContactField();
    } else if (command === 'projects') {
      contactMode = false;
      editingContact = false;
      terminalInput.classList.remove('hidden');
      // --- FIX: Only print Projects ASCII art or title in showSection, not here ---
      // Do NOT print ASCII art or section title here for 'projects' command
      showSection('projects', false, undefined, true); // always pass showAscii true for consistency
    } else if (command === 'skills') {
      contactMode = false;
      editingContact = false;
      terminalInput.classList.remove('hidden');
      // Print the ASCII art header for skills
      if (isMobile) {
        printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">${command}</span>`);
      } else {
        printToTerminal(`<span style=\"color:${getAsciiArtColor()}\">${asciiArt.skills}</span>`);
      }
      // Print the full skills section, including ASCII art and table
      printToTerminal(sections[command], false);
      return;
    } else {
      contactMode = false;
      editingContact = false;
      terminalInput.classList.remove('hidden');
      if (["about","resume","games"].includes(command)) {
        printToTerminal(sections[command], true);
        // Always show the list of games after the games section
        if (command === 'games') {
          setTimeout(() => {
            gameMode = true;
            listGames();
          }, 800);
        }
      } else {
        printToTerminal(sections[command], false);
      }
    }
    return;
  }
  if (command === 'run --all') {
    runAllActive = true;
    contactMode = false;
    editingContact = false;
    terminalInput.classList.remove('hidden');
    runAllSections();
    return;
  } else if (command === 'clear') {
    forceClearAllGames();
    contactMode = false;
    editingContact = false;
    terminalInput.classList.remove('hidden');
    terminalOutput.innerHTML = '';
    // Cancel any ongoing runAllSections
    runAllActive = false;
    printToTerminal('<span style="color:var(--info)">Terminal cleared. Type <b>help</b> to see available commands.</span>');
    return;
  }
  // Restrict game commands to only work in gameMode
  if (['snake','tetris','2048',"whack"].includes(command)) {
    printToTerminal(`<span style="color:var(--ff5555)">$ ${command}</span>`);
    printToTerminal('Game commands only work after entering <span style="color:var(--info)">games</span>.', true);
    return;
  }
  // Function to get current theme from localStorage
  const getCurrentTheme = () => {
    return localStorage.getItem('portfolio_theme') || 'dark';
  };

  // THEME COMMAND (accepts 'theme dark', 'theme light', 'theme hacker', or just 'dark', 'light', 'hacker')
  if (command.startsWith('theme') || themes[command]) {
    let theme = command;
    
    // If using 'theme dark/light/hacker' format
    if (command.startsWith('theme')) {
      const parts = cmd.trim().split(/\s+/);
      if (parts.length === 1) {
        printToTerminal('Usage: theme [dark | light | hacker] type a theme name to apply ', true);
        return;
      }
      theme = parts[1].toLowerCase();
    }
    
    if (!themes[theme]) {
      printToTerminal(`Error: Unknown theme '${theme}'. Try 'dark', 'light', or 'hacker'`, true);
      return;
    }
    
    // Check if theme is already active
    const currentTheme = getCurrentTheme();
    if (currentTheme === theme) {
      printToTerminal(`<span style="color:var(--info)">You're already using the <b>${theme}</b> theme. Type 'theme' to see available options.</span>`, true);
      return;
    }
    
    // Apply the new theme
    applyTheme(theme);
    saveTheme(theme);
    printToTerminal(`<span style="color:var(--info)">Theme switched to <b>${theme}</b>.</span>`, true);
    return;
  }
  if (command) {
    contactMode = false;
    editingContact = false;
    terminalInput.classList.remove('hidden');
    printToTerminal(`<span style="color:var(--ff5555)">$ ${command}</span>`);
    printToTerminal('Command not found. Type <span style="color:var(--info)">help</span> for a list of commands.', true);
    return;
  }
}

function listGames() {
  // Section header in orange
  printToTerminal('<span style="color:var(--accent)">Available games:</span>', true);
  setTimeout(() => {
    // Game names in cyan (dark), blue (light), green (hacker)
    printToTerminal('<span style="color:var(--info)">snake</span> <span style="color:var(--accent)">- Classic snake game</span>', true);
    setTimeout(() => {
      printToTerminal('<span style="color:var(--info)">tetris</span> <span style="color:var(--accent)">- Classic tetris game</span>', true);
      setTimeout(() => {
        printToTerminal('<span style="color:var(--info)">2048</span> <span style="color:var(--accent)">- Play 2048 puzzle</span>', true);
        setTimeout(() => {
          printToTerminal('<span style="color:var(--info)">whack</span> <span style="color:var(--accent)">- Whack-a-Mole reflex game</span>', true);
          setTimeout(() => {
            printToTerminal('<span style="color:var(--accent)">Type the game name to play, or <b>stop</b> to exit game mode.</span>', true);
          }, 600);
        }, 600);
      }, 600);
    }, 600);
  }, 600);
}

// --- SMOOTH RUN --ALL ---
async function runAllSections() {
  runAllActive = true;
  // On mobile: only show title; on desktop/tablet: show only ascii art
  const showAscii = !isMobile;
  await showSection('about', true, undefined, showAscii);
  await showSection('skills', true, undefined, showAscii);
  await delay(1500);
  await showSection('projects', false, undefined, showAscii);
  await delay(2000);
  await showSection('research', true, undefined, showAscii);
  await delay(2000); // Ensure research is fully rendered
  // Insert a break/divider before resume
  const divider = document.createElement('div');
  divider.style.height = '24px';
  divider.style.width = '100%';
  divider.style.clear = 'both';
  divider.style.display = 'block';
  terminalOutput.appendChild(divider);
  scrollTerminalToBottom();
  await showSection('resume', true, undefined, showAscii);
  await delay(1500);
  await showInteractiveContact(showAscii);
  runAllActive = false;
}

function waitForTyping() {
  return new Promise(resolve => {
    // Wait until no .typing-effect is present
    function check() {
      if (!document.querySelector('.typing-effect')) resolve();
      else setTimeout(check, 50);
    }
    check();
  });
}

function showSection(section, typing, noAnimation, showAscii) {
  return new Promise(async resolve => {
    if (showAscii) {
      // Show ONLY ASCII art (no section title)
      if (section === 'projects') {
        // --- FIX: Only print Projects ASCII art on desktop/tablet, and only section title on mobile ---
        if (isMobile) {
          await printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">${section}</span>`);
        } else {
          await printToTerminal(`<span style="color:${getAsciiArtColor()}">${asciiArt.projects}</span>`);
        }
      } else if (section === 'resume') {
        // ... existing code ...
        await printToTerminal(`<span style="color:${getAsciiArtColor()}" data-ascii-art>${asciiArt.resume}</span>`);
        const container = document.createElement('div');
        container.style.marginBottom = '0.5em';
        container.style.color = 'var(--accent)';
        container.style.fontFamily = 'inherit';
        container.style.fontSize = '1em';
        container.id = 'resume-section-message';
        container.innerHTML = 'For details on certifications and achievements, please refer to the full resume : <button id="view-resume-btn" class="send-btn-card" style="margin-left:8px;vertical-align:middle;">View Resume</button>';
        terminalOutput.appendChild(container);
        scrollTerminalToBottom();
        setTimeout(resolve, typing ? 1500 : 2000);
        return;
      } else if (section === 'research') {
        // ... existing code ...
        await printToTerminal(`<span style="color:${getAsciiArtColor()}" data-ascii-art>${asciiArt.research}</span>`);
        // Always print the research content and button after ASCII art, on all devices
        await printToTerminal(sections.research, true);
        setTimeout(resolve, typing ? 1500 : 2000);
        return;
      } else if (section !== 'projects') {
        // ... existing code ...
        await printToTerminal(`<span style="color:${getAsciiArtColor()}">${asciiArt[section]}</span>`);
      }
    } else {
      // Show ONLY section title styled (no ASCII art)
      printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">${section}</span>`);
      // Special handling for resume section on mobile
      if (section === 'resume') {
        // Inline message and button after colon
        const container = document.createElement('div');
        container.style.marginBottom = '0.5em';
        container.style.color = 'var(--accent)';
        container.style.fontFamily = 'inherit';
        container.style.fontSize = '1em';
        container.id = 'resume-section-message';
        container.innerHTML = 'For details on certifications and achievements, please refer to the full resume : <button id="view-resume-btn" class="send-btn-card" style="margin-left:8px;vertical-align:middle;">View Resume</button>';
        terminalOutput.appendChild(container);
        scrollTerminalToBottom();
        setTimeout(resolve, typing ? 1500 : 2000);
        return;
      }
      // Special handling for research section on mobile
      if (section === 'research') {
        // Print research content in a single column with typing effect and button
        await printToTerminal(sections.research, true);
        setTimeout(resolve, typing ? 1500 : 2000);
        return;
      }
    }
    if (section === 'projects') {
      let grid = document.createElement('div');
      grid.innerHTML = sections.projects;
      let gridEl = grid.querySelector('.terminal-card-grid');
      if (gridEl) {
        const shouldAnimate = !noAnimation && !projectCardsAnimated;
        const cards = Array.from(gridEl.children);
        cards.forEach((card, index) => {
          card.className = 'terminal-card';
          if (shouldAnimate) {
            card.classList.add('animate');
            card.addEventListener('animationend', function onAnimationEnd() {
              card.classList.remove('animate');
              card.classList.add('static');
              card.removeEventListener('animationend', onAnimationEnd);
            }, { once: true });
          } else {
            card.classList.add('static');
          }
        });
        if (shouldAnimate) {
          projectCardsAnimated = true;
        }
      }
      terminalOutput.appendChild(grid);
      scrollTerminalToBottom();
      updateAsciiArtColor();
      setTimeout(resolve, 100);
    } else if (section !== 'resume' && section !== 'research') {
      await printToTerminal(sections[section], typing);
      setTimeout(resolve, typing ? 1500 : 2000);
    }
  });
}

function showInteractiveContact(showAscii) {
  return new Promise(resolve => {
    if (showAscii) {
      printToTerminal(`<span style="color:${getAsciiArtColor()}" data-ascii-art>${asciiArt.contact}</span>`);
    } else {
      printToTerminal(`<span style="color:var(--accent);font-size:1.5em;font-weight:bold;text-transform:uppercase;">contact</span>`);
    }
    printToTerminal('<span style="color:var(--ffb86c)">Let\'s Connect!</span>', true);
    setTimeout(() => {
      contactMode = true;
      contactStep = 0;
      contactData = { name: '', email: '', message: '' };
      editingContact = false;
      promptContactField();
      resolve();
    }, 1000);
  });
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Mobile-specific optimizations
let isMobile = false;
let isLandscape = false;
let viewportHeight = window.innerHeight;
let viewportWidth = window.innerWidth;

// Detect mobile device
function detectMobile() {
  isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             window.innerWidth <= 768 || 
             ('ontouchstart' in window);
  
  // Update viewport dimensions
  viewportHeight = window.innerHeight;
  viewportWidth = window.innerWidth;
  isLandscape = viewportWidth > viewportHeight;
  
  // Add mobile class to body
  if (isMobile) {
    document.body.classList.add('mobile-device');
  } else {
    document.body.classList.remove('mobile-device');
  }
  
  // Adjust terminal input for mobile
  if (isMobile) {
    const terminalInput = document.getElementById('terminal-input');
    if (terminalInput) {
      terminalInput.setAttribute('inputmode', 'text');
      terminalInput.setAttribute('autocorrect', 'off');
      terminalInput.setAttribute('autocapitalize', 'off');
      terminalInput.setAttribute('spellcheck', 'false');
    }
  }
}

// Handle viewport changes
function handleViewportChange() {
  detectMobile();
  
  // Adjust game canvas sizes for mobile
  if (snakeGameActive && snakeGame) {
    const canvas = document.getElementById('snake-canvas');
    if (canvas && isMobile) {
      const size = Math.min(viewportWidth * 0.9, viewportHeight * 0.6, 400);
      canvas.width = size;
      canvas.height = size;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
    }
  }
  
  if (tetrisGameActive && tetrisGame) {
    const canvas = document.getElementById('tetris-canvas');
    if (canvas && isMobile) {
      const width = Math.min(viewportWidth * 0.9, 300);
      const height = Math.min(viewportHeight * 0.7, 600);
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }
}

// Mobile keyboard handling
function setupMobileKeyboard() {
  if (!isMobile) return;
  
  const terminalInput = document.getElementById('terminal-input');
  if (!terminalInput) return;
  
  // Prevent zoom on focus
  terminalInput.addEventListener('focus', function() {
    // Small delay to ensure the input is focused
    setTimeout(() => {
      window.scrollTo(0, 0);
      document.body.scrollTop = 0;
      // --- FIX: Scroll input into view above keyboard ---
      terminalInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 100);
  });
  
  // Handle mobile keyboard events
  terminalInput.addEventListener('input', function(e) {
    // Auto-scroll to bottom when typing
    scrollTerminalToBottom();
  });
  
  // Handle mobile keyboard show/hide
  let initialViewportHeight = window.innerHeight;
  
  window.addEventListener('resize', function() {
    if (window.innerHeight < initialViewportHeight) {
      // Keyboard is shown
      document.body.classList.add('keyboard-open');
    } else {
      // Keyboard is hidden
      document.body.classList.remove('keyboard-open');
    }
  });
}

// Mobile touch optimizations
function setupMobileTouch() {
  if (!isMobile) return;
  
  // Prevent double-tap zoom
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function(event) {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, false);
  
  // Improve touch scrolling
  const terminalInner = document.querySelector('.terminal-inner');
  if (terminalInner) {
    terminalInner.style.webkitOverflowScrolling = 'touch';
  }
  
  // Add touch feedback for cards
  const cards = document.querySelectorAll('.terminal-card');
  cards.forEach(card => {
    card.addEventListener('touchstart', function() {
      this.style.transform = 'scale(0.98)';
    });
    
    card.addEventListener('touchend', function() {
      this.style.transform = '';
    });
  });
}

// Mobile game controls
function setupMobileGameControls() {
  if (!isMobile) return;
  // Remove tap-to-rotate for Snake. Only allow swipe for direction.
  let snakeStartX, snakeStartY;
  document.addEventListener('touchstart', function(e) {
    if (snakeGameActive && snakeGame) {
      snakeStartX = e.touches[0].clientX;
      snakeStartY = e.touches[0].clientY;
    }
  });
  document.addEventListener('touchend', function(e) {
    if (snakeGameActive && snakeGame && snakeStartX !== undefined && snakeStartY !== undefined) {
      const endX = e.changedTouches[0].clientX;
      const endY = e.changedTouches[0].clientY;
      const deltaX = endX - snakeStartX;
      const deltaY = endY - snakeStartY;
      const minSwipeDistance = 30;
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (Math.abs(deltaX) > minSwipeDistance) {
          if (deltaX > 0) {
            snakeGame.handleKey({ key: 'ArrowRight' });
          } else {
            snakeGame.handleKey({ key: 'ArrowLeft' });
          }
        }
      } else {
        // Vertical swipe
        if (Math.abs(deltaY) > minSwipeDistance) {
          if (deltaY > 0) {
            snakeGame.handleKey({ key: 'ArrowDown' });
          } else {
            snakeGame.handleKey({ key: 'ArrowUp' });
          }
        }
      }
      snakeStartX = undefined;
      snakeStartY = undefined;
    }
  });
  // Add swipe controls for Tetris
  let tetrisStartX, tetrisStartY;
  document.addEventListener('touchstart', function(e) {
    if (tetrisGameActive && tetrisGame) {
      tetrisStartX = e.touches[0].clientX;
      tetrisStartY = e.touches[0].clientY;
    }
  });
  
  document.addEventListener('touchend', function(e) {
    if (tetrisGameActive && tetrisGame && tetrisStartX !== undefined && tetrisStartY !== undefined) {
      const endX = e.changedTouches[0].clientX;
      const endY = e.changedTouches[0].clientY;
      const deltaX = endX - tetrisStartX;
      const deltaY = endY - tetrisStartY;
      const minSwipeDistance = 30;
      
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (Math.abs(deltaX) > minSwipeDistance) {
          if (deltaX > 0) {
            tetrisGame.handleKey({ key: 'ArrowRight' });
          } else {
            tetrisGame.handleKey({ key: 'ArrowLeft' });
          }
        }
      } else {
        // Vertical swipe
        if (Math.abs(deltaY) > minSwipeDistance) {
          if (deltaY > 0) {
            tetrisGame.handleKey({ key: 'ArrowDown' });
          } else {
            tetrisGame.handleKey({ key: 'ArrowUp' });
          }
        }
      }
      
      tetrisStartX = undefined;
      tetrisStartY = undefined;
    }
  });
  
  // Add tap controls for 2048
  document.addEventListener('touchstart', function(e) {
    if (window._2048GameActive && window._2048Game) {
      const touch = e.touches[0];
      const boardWrap = document.querySelector('#game2048-overlay > div');
      if (boardWrap) {
        const rect = boardWrap.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        // Determine swipe direction based on touch position relative to center
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const minSwipeDistance = 20;
        
        if (Math.abs(x - centerX) > Math.abs(y - centerY)) {
          // Horizontal swipe
          if (Math.abs(x - centerX) > minSwipeDistance) {
            if (x > centerX) {
              window._2048Game.handleKey({ key: 'ArrowRight' });
            } else {
              window._2048Game.handleKey({ key: 'ArrowLeft' });
            }
          }
        } else {
          // Vertical swipe
          if (Math.abs(y - centerY) > minSwipeDistance) {
            if (y > centerY) {
              window._2048Game.handleKey({ key: 'ArrowDown' });
            } else {
              window._2048Game.handleKey({ key: 'ArrowUp' });
            }
          }
        }
      }
    }
  });
  // --- SNAKE GAME TOUCH: Add tap-to-rotate for accessibility ---
  document.addEventListener('touchend', function(e) {
    if (snakeGameActive && snakeGame) {
      if (e.changedTouches.length === 1 && e.changedTouches[0].target.id === 'snake-canvas') {
        // If tap (not swipe), rotate right (simulate ArrowRight)
        if (snakeGame && typeof snakeGame.handleKey === 'function') {
          snakeGame.handleKey({ key: 'ArrowRight' });
        }
      }
    }
  });
  // --- TETRIS GAME: Tap to rotate ---
  document.addEventListener('touchend', function(e) {
    if (tetrisGameActive && tetrisGame) {
      if (e.changedTouches.length === 1 && e.changedTouches[0].target.id === 'tetris-canvas') {
        // If tap (not swipe), rotate (simulate ArrowUp)
        if (tetrisGame && typeof tetrisGame.handleKey === 'function') {
          tetrisGame.handleKey({ key: 'ArrowUp' });
        }
      }
    }
  });
}

// Mobile-specific command suggestions
function setupMobileCommandSuggestions() {
  if (!isMobile) return;
  
  const commonCommands = ['help', 'about', 'skills', 'projects', 'contact', 'games'];
  const terminalInput = document.getElementById('terminal-input');
  
  if (terminalInput) {
    terminalInput.addEventListener('input', function(e) {
      const value = e.target.value.toLowerCase();
      
      // Show command suggestions for mobile
      if (value.length > 0) {
        const suggestions = commonCommands.filter(cmd => cmd.startsWith(value));
        if (suggestions.length > 0) {
          // You could implement a suggestion dropdown here
          // For now, we'll just log the suggestions
          console.log('Suggestions:', suggestions);
        }
      }
    });
  }
}

// Mobile performance optimizations
function optimizeForMobile() {
  if (!isMobile) return;
  
  // Reduce animation complexity on mobile
  const style = document.createElement('style');
  style.textContent = `
    @media (max-width: 768px) {
      .terminal-card {
        transition: transform 0.2s ease;
      }
      
      .terminal-card:hover {
        transform: translateY(-2px);
      }
      
      .typing-effect {
        animation-duration: 0.8s;
      }
      
      /* Hide ASCII art on mobile */
      .about-ascii, .skills-ascii, .research-ascii {
        display: none !important;
      }
      
      /* Make skills table mobile-friendly */
      .skills-flex {
        flex-direction: column !important;
        gap: 16px !important;
      }
      
      .skills-table table {
        font-size: 0.9em !important;
        border-spacing: 0 8px !important;
      }
      
      .skills-table th,
      .skills-table td {
        padding: 8px 12px !important;
        font-size: 0.85em !important;
      }
      
      .skills-table th:first-child {
        width: 120px !important;
        min-width: 120px !important;
      }
      
      /* Make about and research sections mobile-friendly */
      .about-flex, .research-flex {
        flex-direction: column !important;
        gap: 16px !important;
      }
    }
  `;
  document.head.appendChild(style);
  
  // Optimize scrolling performance
  document.body.style.webkitOverflowScrolling = 'touch';
}

// Initialize mobile optimizations
function initMobileOptimizations() {
  detectMobile();
  setupMobileKeyboard();
  setupMobileTouch();
  setupMobileGameControls();
  setupMobileCommandSuggestions();
  optimizeForMobile();
  
  // Listen for orientation changes
  window.addEventListener('orientationchange', function() {
    setTimeout(handleViewportChange, 100);
  });
  
  // Listen for resize events
  window.addEventListener('resize', handleViewportChange);
  
  // Listen for visibility changes (app switching on mobile)
  document.addEventListener('visibilitychange', function() {
    if (!document.hidden && isMobile) {
      // Re-focus input when returning to app
      setTimeout(() => {
        const terminalInput = document.getElementById('terminal-input');
        if (terminalInput) {
          terminalInput.focus();
        }
      }, 100);
    }
  });
}

// Enhanced scroll function for mobile
function scrollTerminalToBottom() {
  // Always scroll to bottom when called, regardless of contactMode
  // This ensures the terminal scrolls down when contact fields are focused
  terminalOutput.scrollTop = terminalOutput.scrollHeight;
  
  const terminalInner = document.querySelector('.terminal-inner');
  if (terminalInner) {
    // Smooth scroll for mobile
    if (isMobile) {
      terminalInner.scrollTo({
        top: terminalInner.scrollHeight,
        behavior: 'smooth'
      });
    } else {
      terminalInner.scrollTop = terminalInner.scrollHeight;
    }
  }
}

// Initialize everything when DOM is loaded
window.onload = () => {
  // Initialize mobile optimizations first
  initMobileOptimizations();
  
  printToTerminal('<span style="color:var(--accent)">      ▄▀▄     ▄▀▄\n     ▄█░░▀▀▀▀▀░░█▄\n ▄▄  █░░░░░░░░░░░█   ▄▄\n█▄▄█ █░░▀░░┬░░▀░░█  █▄▄█\n █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█\n █░░╦─╦╔╗╦─╔╗╔╗╔╦╗╔╗░░█\n █░░║║║╠─║ ║─║║║║║╠─░░█\n █░░╚╩╝╚╝╚╝╚╝╚╝╩─╩╚╝░░█\n █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█</span>', false);
  printToTerminal('Type <b>help</b> to see available commands.', true);
  
  // Focus input with mobile considerations
  const terminalInput = document.getElementById('terminal-input');
  if (terminalInput) {
    // Delay focus on mobile to prevent keyboard popup
    if (isMobile) {
      setTimeout(() => {
        terminalInput.focus();
      }, 500);
    } else {
      terminalInput.focus();
    }
  }
};

document.querySelector('.terminal-inner').addEventListener('click', function(e) {
  if (!e.target.closest('a, button, input, textarea, select')) {
    // Save current scroll position
    const scrollY = document.querySelector('.terminal-inner').scrollTop;
    terminalInput.focus();
    // Restore scroll position
    document.querySelector('.terminal-inner').scrollTop = scrollY;
  }
});

// Terminal is now full-screen and non-draggable
// dragElement(document.querySelector('.terminal-outer'), document.querySelector('.terminal-header'));

function dragElement(elmnt, handle) {
  let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  handle.onmousedown = dragMouseDown;

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
    elmnt.style.transform = "none";
  }

  function closeDragElement() {
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

terminalInput.addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    const value = terminalInput.value;
    if (value) {
      // Append the prompt + command to the output area
      const cmdDiv = document.createElement('div');
      cmdDiv.innerHTML = `<span style="color:var(--prompt);font-weight:bold;font-family:monospace;">${terminalPromptStr}</span> <span style="color:var(--e0e0e0);">${value}</span>`;
      terminalOutput.appendChild(cmdDiv);
      scrollTerminalToBottom();
      // Process the command as before
      if (contactMode) {
        if (value.trim().toLowerCase() === 'cancel') {
          contactMode = false;
          contactStep = 0;
          contactData = { name: '', email: '', message: '' };
          editingContact = false;
          contactMessageSent = false;
          printToTerminal('<span style="color:var(--ffb86c)">Contact form cancelled. You can continue using the terminal.</span>', true);
          terminalInput.value = '';
          return;
        }
        if (contactStep === 0) {
          contactData.name = value;
          contactStep = 1;
          promptContactField();
          setTimeout(() => {
            document.querySelector('.terminal-inner').scrollTop = document.querySelector('.terminal-inner').scrollHeight;
          }, 10);
        } else if (contactStep === 1) {
          contactData.email = value;
          contactStep = 2;
          promptContactField();
          setTimeout(() => {
            document.querySelector('.terminal-inner').scrollTop = document.querySelector('.terminal-inner').scrollHeight;
          }, 10);
        } else if (contactStep === 2) {
          contactData.message = value;
          contactStep = 3;
          promptContactField();
          setTimeout(() => {
            document.querySelector('.terminal-inner').scrollTop = document.querySelector('.terminal-inner').scrollHeight;
          }, 10);
        }
        terminalInput.value = '';
      } else {
        history.push(value);
        historyIndex = history.length;
        handleCommand(value);
        terminalInput.value = '';
      }
    }
  } else if (e.key === 'ArrowUp') {
    if (!contactMode && historyIndex > 0) {
      historyIndex--;
      terminalInput.value = history[historyIndex];
    }
    e.preventDefault();
  } else if (e.key === 'ArrowDown') {
    if (!contactMode && historyIndex < history.length - 1) {
      historyIndex++;
      terminalInput.value = history[historyIndex];
    } else if (!contactMode) {
      terminalInput.value = '';
      historyIndex = history.length;
    }
    e.preventDefault();
  }
});


function startSnakeGame() {
  snakeGameActive = true;
  // Create overlay
  snakeOverlay = document.createElement('div');
  snakeOverlay.id = 'snake-overlay';
  snakeOverlay.style.position = 'absolute';
  snakeOverlay.style.top = '0';
  snakeOverlay.style.left = '0';
  snakeOverlay.style.width = '100%';
  snakeOverlay.style.height = '100%';
  snakeOverlay.style.position = 'absolute';
  snakeOverlay.style.top = '0';
  snakeOverlay.style.left = '0';
  snakeOverlay.style.width = '100%';
  snakeOverlay.style.height = '100%';
  if (document.documentElement.classList.contains('hacker-theme')) {
    snakeOverlay.style.background = '#000';
  } else {
    snakeOverlay.style.background = 'rgba(24,24,26,0.98)';
  }
  snakeOverlay.style.display = 'flex';
  snakeOverlay.style.flexDirection = 'column';
  snakeOverlay.style.alignItems = 'center';
  snakeOverlay.style.justifyContent = 'center';
  snakeOverlay.style.zIndex = '100';
  snakeOverlay.style.transition = 'opacity 0.4s';
  snakeOverlay.style.opacity = '1';
  // Canvas
  const canvas = document.createElement('canvas');
  canvas.id = 'snake-canvas';
  canvas.width = 400;
  canvas.height = 400;
  if (document.documentElement.classList.contains('hacker-theme')) {
    canvas.style.background = '#000';
    canvas.style.border = '2px solid #39ff14';
    canvas.style.boxShadow = '0 0 16px #39ff1480, 0 0 0 2px #000';
  } else {
    canvas.style.background = '#18181a';
    canvas.style.border = '2px solid #ffb86c';
    canvas.style.boxShadow = '0 2px 12px #000a, 0 0 0 2px #18181a';
  }
  // Score
  const scoreDiv = document.createElement('div');
  scoreDiv.id = 'snake-score';
  scoreDiv.style.textAlign = 'center';
  if (document.documentElement.classList.contains('hacker-theme')) {
    scoreDiv.style.color = '#39ff14';
    scoreDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
    scoreDiv.style.fontSize = '1.2em';
    scoreDiv.style.marginTop = '12px';
  } else {
    scoreDiv.style.color = '#7fffd4';
    scoreDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
    scoreDiv.style.fontSize = '1.2em';
    scoreDiv.style.marginTop = '12px';
  }
  scoreDiv.textContent = 'Score: 0';
  // Message
  const msgDiv = document.createElement('div');
  msgDiv.style.textAlign = 'center';
  if (document.documentElement.classList.contains('hacker-theme')) {
    msgDiv.style.color = '#39ff14';
    msgDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
    msgDiv.style.marginTop = '8px';
  } else {
    msgDiv.style.color = '#ffb86c';
    msgDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
    msgDiv.style.marginTop = '8px';
  }
  msgDiv.innerHTML = isMobile ? 'Swipe to control. Type <b>stop</b> or press <b>Esc</b> to exit.' : 'Type <b>stop</b> or press <b>Esc</b> to exit.';
  // Add to overlay
  snakeOverlay.appendChild(canvas);
  snakeOverlay.appendChild(scoreDiv);
  snakeOverlay.appendChild(msgDiv);
  // Add overlay to terminal
  const terminalOuter = document.querySelector('.terminal-outer');
  terminalOuter.appendChild(snakeOverlay);
  // Start game logic
  snakeGame = new SnakeGame(canvas, scoreDiv, () => stopSnakeGame(false));
  document.addEventListener('keydown', snakeGameKeyHandler);
  // Listen for theme changes
  window.addEventListener('themechange', updateSnakeTheme);
}

function stopSnakeGame(fromCommand) {
  snakeGameActive = false;
  let lastScore = null;
  if (snakeGame && typeof snakeGame.stop === 'function') {
    if (snakeGame.score !== undefined) lastScore = snakeGame.score;
    snakeGame.stop();
  }
  snakeGame = null;
  if (snakeOverlay) {
    snakeOverlay.style.opacity = '0';
    setTimeout(() => {
      if (snakeOverlay && snakeOverlay.parentNode) snakeOverlay.parentNode.removeChild(snakeOverlay);
      snakeOverlay = null;
      terminalInput.value = '';
      terminalInput.focus();
      if (fromCommand) {
        printToTerminal('<span style="color:var(--ffb86c)">Exited Snake. Type <b>snake</b> to play again', true);
      }
      if (lastScore !== null) {
        let msg = `<span style="color:var(--info)">Your score was <b>${lastScore}</b>! `;
        if (lastScore < 5) msg += "Keep practicing and you'll get better!";
        else if (lastScore < 15) msg += "Nice effort! Try to beat your high score.";
        else msg += "Awesome! You're a Snake master!";
        msg += '</span>';
        printToTerminal(msg, true);
      }
    }, 400);
  }
  document.removeEventListener('keydown', snakeGameKeyHandler);
  window.removeEventListener('themechange', updateSnakeTheme);
}

function snakeGameKeyHandler(e) {
  if (!snakeGameActive) return;
  if (e.key === 'Escape') {
    stopSnakeGame(true);
    return;
  }
  if (snakeGame && typeof snakeGame.handleKey === 'function') {
    snakeGame.handleKey(e);
  }
}

// Snake game implementation with border wrap-around
class SnakeGame {
  constructor(canvas, scoreDiv, onGameOver) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.scoreDiv = scoreDiv;
    this.onGameOver = onGameOver;
    this.size = 20;
    this.direction = 'right';
    this.nextDirection = 'right';
    this.snake = [ {x: 8, y: 10}, {x: 7, y: 10}, {x: 6, y: 10} ];
    this.food = this.randomFood();
    this.score = 0;
    this.alive = true;
    this.interval = setInterval(() => this.gameLoop(), 110);
    this.draw();
  }
  stop() {
    clearInterval(this.interval);
    this.alive = false;
  }
  handleKey(e) {
    if (e.key === 'ArrowUp' && this.direction !== 'down') this.nextDirection = 'up';
    else if (e.key === 'ArrowDown' && this.direction !== 'up') this.nextDirection = 'down';
    else if (e.key === 'ArrowLeft' && this.direction !== 'right') this.nextDirection = 'left';
    else if (e.key === 'ArrowRight' && this.direction !== 'left') this.nextDirection = 'right';
  }
  gameLoop() {
    if (!this.alive) return;
    this.direction = this.nextDirection;
    const head = { ...this.snake[0] };
    if (this.direction === 'up') head.y = (head.y - 1 + 20) % 20;
    else if (this.direction === 'down') head.y = (head.y + 1) % 20;
    else if (this.direction === 'left') head.x = (head.x - 1 + 20) % 20;
    else if (this.direction === 'right') head.x = (head.x + 1) % 20;
    // Check collision with self
    if (this.snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      this.gameOver();
      return;
    }
    this.snake.unshift(head);
    if (head.x === this.food.x && head.y === this.food.y) {
      this.score++;
      this.scoreDiv.textContent = 'Score: ' + this.score;
      this.food = this.randomFood();
    } else {
      this.snake.pop();
    }
    this.draw();
  }
  gameOver() {
    this.stop();
    if (document.documentElement.classList.contains('hacker-theme')) {
      this.ctx.fillStyle = '#000';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.font = 'bold 2em Fira Mono, Consolas, Courier New, monospace';
      this.ctx.fillStyle = '#39ff14';
      this.ctx.textAlign = 'center';
      this.ctx.fillText('Game Over', this.canvas.width/2, this.canvas.height/2-10);
      this.ctx.font = '1.2em Fira Mono, Consolas, Courier New, monospace';
      this.ctx.fillText('Score: ' + this.score, this.canvas.width/2, this.canvas.height/2+30);
    } else {
      this.ctx.fillStyle = '#18181a';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.font = 'bold 2em Fira Mono, Consolas, Courier New, monospace';
      this.ctx.fillStyle = '#ff5555';
      this.ctx.textAlign = 'center';
      this.ctx.fillText('Game Over', this.canvas.width/2, this.canvas.height/2-10);
      this.ctx.fillStyle = '#ffb86c';
      this.ctx.font = '1.2em Fira Mono, Consolas, Courier New, monospace';
      this.ctx.fillText('Score: ' + this.score, this.canvas.width/2, this.canvas.height/2+30);
    }
    setTimeout(() => {
      if (typeof this.onGameOver === 'function') this.onGameOver();
    }, 1200);
  }
  randomFood() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random()*20), y: Math.floor(Math.random()*20) };
    } while (this.snake.some(seg => seg.x === pos.x && seg.y === pos.y));
    return pos;
  }
  draw() {
    // Use theme-aware colors
    this.ctx.fillStyle = getGameBg();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    // Draw food
    if (document.documentElement.classList.contains('hacker-theme')) {
      this.ctx.fillStyle = '#7fff50'; // bright green for food
    } else {
      this.ctx.fillStyle = getGameInfo();
    }
    this.ctx.fillRect(this.food.x*this.size, this.food.y*this.size, this.size, this.size);
    // Draw snake
    for (let i = 0; i < this.snake.length; i++) {
      if (document.documentElement.classList.contains('hacker-theme')) {
        this.ctx.fillStyle = '#39ff14'; // all green for hacker theme
      } else {
        this.ctx.fillStyle = i === 0 ? getGameAccent() : '#ff6f3c';
      }
      this.ctx.fillRect(this.snake[i].x*this.size, this.snake[i].y*this.size, this.size, this.size);
    }
  }
  updateTheme() {
    // Redraw with new theme colors
    this.draw();
    if (this.scoreDiv) {
      if (document.documentElement.classList.contains('hacker-theme')) {
        this.scoreDiv.style.color = '#39ff14';
      } else {
        this.scoreDiv.style.color = getGameInfo();
      }
    }
  }
}

function startTetrisGame() {
  tetrisGameActive = true;
  // Create overlay
  tetrisOverlay = document.createElement('div');
  tetrisOverlay.id = 'tetris-overlay';
  tetrisOverlay.style.position = 'absolute';
  tetrisOverlay.style.top = '0';
  tetrisOverlay.style.left = '0';
  tetrisOverlay.style.width = '100%';
  tetrisOverlay.style.height = '100%';
  tetrisOverlay.style.background = 'rgba(24,24,26,0.98)';
  tetrisOverlay.style.display = 'flex';
  tetrisOverlay.style.flexDirection = 'column';
  tetrisOverlay.style.alignItems = 'center';
  tetrisOverlay.style.justifyContent = 'center';
  tetrisOverlay.style.zIndex = '100';
  tetrisOverlay.style.transition = 'opacity 0.4s';
  tetrisOverlay.style.opacity = '1';
  // Canvas
  const canvas = document.createElement('canvas');
  canvas.id = 'tetris-canvas';
  canvas.width = 300;
  canvas.height = 600;
  canvas.style.background = getGameBg();
  canvas.style.display = 'block';
  canvas.style.border = '2px solid ' + getGameAccent();
  canvas.style.boxShadow = '0 2px 12px #000a, 0 0 0 2px ' + getGameBg();
  // Score
  const scoreDiv = document.createElement('div');
  scoreDiv.id = 'tetris-score';
  scoreDiv.style.textAlign = 'center';
  scoreDiv.style.color = getGameInfo();
  scoreDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
  scoreDiv.style.fontSize = '1.2em';
  scoreDiv.style.marginTop = '12px';
  scoreDiv.textContent = 'Score: 0';
  // Message
  const msgDiv = document.createElement('div');
  msgDiv.style.textAlign = 'center';
  msgDiv.style.color = getGameAccent();
  msgDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
  msgDiv.style.marginTop = '8px';
  msgDiv.innerHTML = isMobile ? 'Swipe to control. Type <b>stop</b> or press <b>Esc</b> to exit.' : 'Type <b>stop</b> or press <b>Esc</b> to exit.';
  // Add to overlay
  tetrisOverlay.appendChild(canvas);
  tetrisOverlay.appendChild(scoreDiv);
  tetrisOverlay.appendChild(msgDiv);
  // Add overlay to terminal
  const terminalOuter = document.querySelector('.terminal-outer');
  terminalOuter.appendChild(tetrisOverlay);
  // Start game logic
  tetrisGame = new TetrisGame(canvas, scoreDiv, () => stopTetrisGame(false));
  document.addEventListener('keydown', tetrisGameKeyHandler);
  // Listen for theme changes
  window.addEventListener('themechange', updateTetrisTheme);
}

function stopTetrisGame(fromCommand) {
  tetrisGameActive = false;
  let lastScore = null;
  if (tetrisGame && typeof tetrisGame.stop === 'function') {
    if (tetrisGame.score !== undefined) lastScore = tetrisGame.score;
    tetrisGame.stop();
  }
  tetrisGame = null;
  if (tetrisOverlay) {
    tetrisOverlay.style.opacity = '0';
    setTimeout(() => {
      if (tetrisOverlay && tetrisOverlay.parentNode) tetrisOverlay.parentNode.removeChild(tetrisOverlay);
      tetrisOverlay = null;
      terminalInput.value = '';
      terminalInput.focus();
      if (fromCommand) {
        printToTerminal('<span style="color:var(--ffb86c)">Exited Tetris. Type <b>tetris</b> to play again', true);
      }
      if (lastScore !== null) {
        let msg = `<span style=\"color:${getGameInfo()}\">Your score was <b>${lastScore}</b>!`;
        if (lastScore < 100) msg += " Try to clear more lines!";
        else if (lastScore < 500) msg += " Nice! You're a Tetris builder.";
        else msg += " Amazing! Tetris legend!";
        msg += '</span>';
        printToTerminal(msg, true);
      }
    }, 400);
  }
  document.removeEventListener('keydown', tetrisGameKeyHandler);
  window.removeEventListener('themechange', updateTetrisTheme);
}

function tetrisGameKeyHandler(e) {
  if (!tetrisGameActive) return;
  if (e.key === 'Escape') {
    stopTetrisGame(true);
    return;
  }
  if (tetrisGame && typeof tetrisGame.handleKey === 'function') {
    tetrisGame.handleKey(e);
  }
}

function updateTetrisTheme() {
  if (!tetrisGameActive || !tetrisGame) return;
  tetrisGame.updateTheme();
  if (tetrisOverlay) {
    const canvas = document.getElementById('tetris-canvas');
    if (canvas) {
      canvas.style.background = getGameBg();
      canvas.style.border = '2px solid ' + getGameAccent();
      canvas.style.boxShadow = '0 2px 12px #000a, 0 0 0 2px ' + getGameBg();
    }
    const scoreDiv = document.getElementById('tetris-score');
    if (scoreDiv) scoreDiv.style.color = getGameInfo();
    // Message color
    if (tetrisOverlay.lastChild) tetrisOverlay.lastChild.style.color = getGameAccent();
  }
}

function getGameBg() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) return '#000';
  if (getComputedStyle(root).getPropertyValue('--bg')) return getComputedStyle(root).getPropertyValue('--bg');
  return '#18181a';
}
function getGameAccent() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) return '#39ff14';
  if (getComputedStyle(root).getPropertyValue('--accent')) return getComputedStyle(root).getPropertyValue('--accent');
  return '#ffb86c';
}
function getGameInfo() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) return '#7fffd4';
  if (getComputedStyle(root).getPropertyValue('--info')) return getComputedStyle(root).getPropertyValue('--info');
  return '#7fffd4';
}

// Tetris game implementation
class TetrisGame {
  constructor(canvas, scoreDiv, onGameOver) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.scoreDiv = scoreDiv;
    this.onGameOver = onGameOver;
    this.rows = 20;
    this.cols = 10;
    this.size = 30;
    this.board = this.createBoard();
    this.score = 0;
    this.alive = true;
    this.dropInterval = 500;
    this.dropCounter = 0;
    this.lastTime = null;
    this.tetromino = null;
    this.tetroPos = {x: 3, y: 0};
    this.tetroColor = '';
    this.nextTetromino = this.randomTetromino();
    this.nextColor = this.randomColor();
    this.spawnTetromino();
    this.updateTheme();
    this.loop = (time) => {
      if (!this.alive) return;
      if (!this.lastTime) this.lastTime = time;
      const delta = time - this.lastTime;
      this.lastTime = time;
      this.dropCounter += delta;
      if (this.dropCounter > this.dropInterval) {
        this.moveDown();
        this.dropCounter = 0;
      }
      this.draw();
      requestAnimationFrame(this.loop);
    };
    requestAnimationFrame(this.loop);
  }
  stop() {
    this.alive = false;
  }
  createBoard() {
    return Array.from({length: this.rows}, () => Array(this.cols).fill(null));
  }
  tetrominoShapes() {
    return {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
    };
  }
  tetrominoColors() {
    // Theme-aware colors
    const accent = getGameAccent();
    const info = getGameInfo();
    const hacker = document.documentElement.classList.contains('hacker-theme');
    return {
      I: hacker ? '#39ff14' : '#7fffd4',
      O: accent,
      T: hacker ? '#39ff14' : '#ffb86c',
      S: hacker ? '#39ff14' : '#50fa7b',
      Z: hacker ? '#39ff14' : '#ff5555',
      J: hacker ? '#39ff14' : '#2563eb',
      L: hacker ? '#39ff14' : '#ff6f3c',
    };
  }
  randomTetromino() {
    const keys = Object.keys(this.tetrominoShapes());
    return keys[Math.floor(Math.random()*keys.length)];
  }
  randomColor() {
    const colors = Object.values(this.tetrominoColors());
    return colors[Math.floor(Math.random()*colors.length)];
  }
  spawnTetromino() {
    this.tetromino = this.tetrominoShapes()[this.nextTetromino];
    this.tetroColor = this.tetrominoColors()[this.nextTetromino];
    this.tetroPos = {x: 3, y: 0};
    this.nextTetromino = this.randomTetromino();
    this.nextColor = this.tetrominoColors()[this.nextTetromino];
    if (this.collides(this.tetroPos.x, this.tetroPos.y, this.tetromino)) {
      this.gameOver();
    }
  }
  moveDown() {
    if (!this.move(0, 1)) {
      this.merge();
      this.clearLines();
      this.spawnTetromino();
    }
  }
  move(dx, dy) {
    if (!this.collides(this.tetroPos.x + dx, this.tetroPos.y + dy, this.tetromino)) {
      this.tetroPos.x += dx;
      this.tetroPos.y += dy;
      return true;
    }
    return false;
  }
  rotate() {
    const rotated = this.tetromino[0].map((_, i) => this.tetromino.map(row => row[i])).reverse();
    if (!this.collides(this.tetroPos.x, this.tetroPos.y, rotated)) {
      this.tetromino = rotated;
    }
  }
  hardDrop() {
    while (this.move(0, 1)) {}
    this.moveDown();
    this.dropCounter = 0;
  }
  collides(x, y, shape) {
    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          const nx = x + col;
          const ny = y + row;
          if (nx < 0 || nx >= this.cols || ny >= this.rows) return true;
          if (ny >= 0 && this.board[ny][nx]) return true;
        }
      }
    }
    return false;
  }
  merge() {
    for (let row = 0; row < this.tetromino.length; row++) {
      for (let col = 0; col < this.tetromino[row].length; col++) {
        if (this.tetromino[row][col]) {
          const nx = this.tetroPos.x + col;
          const ny = this.tetroPos.y + row;
          if (ny >= 0 && nx >= 0 && nx < this.cols && ny < this.rows) {
            this.board[ny][nx] = this.tetroColor;
          }
        }
      }
    }
  }
  clearLines() {
    let lines = 0;
    for (let row = this.rows - 1; row >= 0; row--) {
      if (this.board[row].every(cell => cell)) {
        this.board.splice(row, 1);
        this.board.unshift(Array(this.cols).fill(null));
        lines++;
        row++;
      }
    }
    if (lines > 0) {
      this.score += lines * 100;
      this.scoreDiv.textContent = 'Score: ' + this.score;
      this.dropInterval = Math.max(100, this.dropInterval - lines * 10);
    }
  }
  handleKey(e) {
    if (!this.alive) return;
    if (e.key === 'ArrowLeft') this.move(-1, 0);
    else if (e.key === 'ArrowRight') this.move(1, 0);
    else if (e.key === 'ArrowDown') this.move(0, 1);
    else if (e.key === 'ArrowUp') this.rotate();
    else if (e.key === ' ') this.hardDrop();
  }
  gameOver() {
    this.stop();
    this.ctx.fillStyle = getGameBg();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.font = 'bold 2em Fira Mono, Consolas, Courier New, monospace';
    this.ctx.fillStyle = '#ff5555';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('Game Over', this.canvas.width/2, this.canvas.height/2-10);
    this.ctx.fillStyle = getGameAccent();
    this.ctx.font = '1.2em Fira Mono, Consolas, Courier New, monospace';
    this.ctx.fillText('Score: ' + this.score, this.canvas.width/2, this.canvas.height/2+30);
    setTimeout(() => {
      if (typeof this.onGameOver === 'function') this.onGameOver();
    }, 1200);
  }
  updateTheme() {
    // Redraw with new theme colors
    this.draw();
    if (this.scoreDiv) this.scoreDiv.style.color = getGameInfo();
  }
  draw() {
    // Board
    this.ctx.fillStyle = getGameBg();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    // Draw placed blocks
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.cols; col++) {
        if (this.board[row][col]) {
          this.ctx.fillStyle = this.board[row][col];
          this.ctx.fillRect(col*this.size, row*this.size, this.size, this.size);
          this.ctx.strokeStyle = getGameBg();
          this.ctx.lineWidth = 2;
          this.ctx.strokeRect(col*this.size, row*this.size, this.size, this.size);
        }
      }
    }
    // Draw current tetromino
    for (let row = 0; row < this.tetromino.length; row++) {
      for (let col = 0; col < this.tetromino[row].length; col++) {
        if (this.tetromino[row][col]) {
          this.ctx.fillStyle = this.tetroColor;
          const nx = this.tetroPos.x + col;
          const ny = this.tetroPos.y + row;
          if (ny >= 0) {
            this.ctx.fillRect(nx*this.size, ny*this.size, this.size, this.size);
            this.ctx.strokeStyle = getGameBg();
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(nx*this.size, ny*this.size, this.size, this.size);
          }
        }
      }
    }
  }
}

function start2048Game() {
  window._2048GameActive = true;
  // Create overlay
  const overlay = document.createElement('div');
  overlay.id = 'game2048-overlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.background = 'rgba(24,24,26,0.98)';
  overlay.style.display = 'flex';
  overlay.style.flexDirection = 'column';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.zIndex = '100';
  overlay.style.transition = 'opacity 0.4s';
  overlay.style.opacity = '1';
  // Responsive board container
  const boardWrap = document.createElement('div');
  boardWrap.style.display = 'flex';
  boardWrap.style.flexDirection = 'column';
  boardWrap.style.alignItems = 'center';
  boardWrap.style.justifyContent = 'center';
  boardWrap.style.width = 'min(90vw, 420px)';
  boardWrap.style.height = 'min(90vw, 420px)';
  boardWrap.style.maxWidth = '420px';
  boardWrap.style.maxHeight = '420px';
  boardWrap.style.background = getGameBg();
  boardWrap.style.border = '4px solid ' + getGameAccent();
  boardWrap.style.borderRadius = '18px';
  boardWrap.style.boxShadow = '0 4px 32px #000a, 0 0 0 2px ' + getGameBg();
  boardWrap.style.position = 'relative';
  // Score
  const scoreDiv = document.createElement('div');
  scoreDiv.id = 'game2048-score';
  scoreDiv.style.textAlign = 'center';
  scoreDiv.style.color = getGameInfo();
  scoreDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
  scoreDiv.style.fontSize = '1.2em';
  scoreDiv.style.marginBottom = '12px';
  scoreDiv.textContent = 'Score: 0';
  // Message
  const msgDiv = document.createElement('div');
  msgDiv.style.textAlign = 'center';
  msgDiv.style.color = getGameAccent();
  msgDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
  msgDiv.style.marginTop = '8px';
  msgDiv.innerHTML = 'Use <b>Arrow keys</b> to play. Type <b>stop</b> or press <b>Esc</b> to exit.';
  // Board
  const boardDiv = document.createElement('div');
  boardDiv.id = 'game2048-board';
  boardDiv.style.width = 'min(80vw, 360px)';
  boardDiv.style.height = 'min(80vw, 360px)';
  boardDiv.style.maxWidth = '360px';
  boardDiv.style.maxHeight = '360px';
  boardDiv.style.display = 'grid';
  boardDiv.style.gridTemplateColumns = 'repeat(4, 1fr)';
  boardDiv.style.gridTemplateRows = 'repeat(4, 1fr)';
  boardDiv.style.gap = '12px';
  boardDiv.style.background = getGameBg();
  boardDiv.style.borderRadius = '12px';
  boardDiv.style.padding = '12px';
  // Add to overlay
  boardWrap.appendChild(scoreDiv);
  boardWrap.appendChild(boardDiv);
  overlay.appendChild(boardWrap);
  overlay.appendChild(msgDiv);
  // Add overlay to terminal
  document.querySelector('.terminal-outer').appendChild(overlay);
  // Start game logic
  window._2048Game = new Game2048(boardDiv, scoreDiv, () => stop2048Game(false));
  document.addEventListener('keydown', game2048KeyHandler);
  window.addEventListener('themechange', update2048Theme);
}

function stop2048Game(fromCommand) {
  window._2048GameActive = false;
  let lastScore = null;
  if (window._2048Game && typeof window._2048Game.stop === 'function') {
    if (window._2048Game.score !== undefined) lastScore = window._2048Game.score;
    window._2048Game.stop();
  }
  window._2048Game = null;
  const overlay = document.getElementById('game2048-overlay');
  if (overlay) {
    overlay.style.opacity = '0';
    setTimeout(() => {
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
      terminalInput.value = '';
      terminalInput.focus();
      if (fromCommand) {
        printToTerminal('<span style="color:var(--ffb86c)">Exited 2048. Type <b>2048</b> to play again', true);
      }
      if (lastScore !== null) {
        let msg = `<span style=\"color:${getGameInfo()}\">Your score was <b>${lastScore}</b>!`;
        if (lastScore < 256) msg += " Try to reach 512!";
        else if (lastScore < 1024) msg += " Nice! Can you get 2048?";
        else msg += " Incredible! 2048 master!";
        msg += '</span>';
        printToTerminal(msg, true);
      }
    }, 400);
  }
  document.removeEventListener('keydown', game2048KeyHandler);
  window.removeEventListener('themechange', update2048Theme);
}

function game2048KeyHandler(e) {
  if (!window._2048GameActive) return;
  if (e.key === 'Escape') {
    stop2048Game(true);
    return;
  }
  if (window._2048Game && typeof window._2048Game.handleKey === 'function') {
    window._2048Game.handleKey(e);
  }
}

function update2048Theme() {
  if (!window._2048GameActive || !window._2048Game) return;
  window._2048Game.updateTheme();
}

// 2048 Game Implementation
class Game2048 {
  constructor(boardDiv, scoreDiv, onGameOver) {
    this.boardDiv = boardDiv;
    this.scoreDiv = scoreDiv;
    this.onGameOver = onGameOver;
    this.size = 4;
    this.score = 0;
    this.won = false;
    this.over = false;
    this.board = this.createBoard();
    this.addRandomTile();
    this.addRandomTile();
    this.draw();
  }
  stop() { this.over = true; }
  createBoard() {
    return Array.from({length: this.size}, () => Array(this.size).fill(0));
  }
  addRandomTile() {
    const empty = [];
    for (let r = 0; r < this.size; r++) for (let c = 0; c < this.size; c++) if (this.board[r][c] === 0) empty.push([r, c]);
    if (empty.length === 0) return;
    const [r, c] = empty[Math.floor(Math.random() * empty.length)];
    this.board[r][c] = Math.random() < 0.9 ? 2 : 4;
  }
  handleKey(e) {
    if (this.over) return;
    let moved = false;
    if (e.key === 'ArrowUp') moved = this.move('up');
    else if (e.key === 'ArrowDown') moved = this.move('down');
    else if (e.key === 'ArrowLeft') moved = this.move('left');
    else if (e.key === 'ArrowRight') moved = this.move('right');
    if (moved) {
      this.addRandomTile();
      this.draw();
      if (this.isGameOver()) {
        this.over = true;
        setTimeout(() => this.showGameOver(), 300);
      }
      if (this.isGameWon() && !this.won) {
        this.won = true;
        setTimeout(() => this.showGameWon(), 300);
      }
    }
  }
  move(dir) {
    let moved = false;
    let b = this.board;
    let size = this.size;
    let merged = Array.from({length: size}, () => Array(size).fill(false));
    function slide(row) {
      let arr = row.filter(x => x);
      for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] === arr[i+1]) {
          arr[i] *= 2;
          this.score += arr[i];
          arr[i+1] = 0;
        }
      }
      arr = arr.filter(x => x);
      while (arr.length < size) arr.push(0);
      return arr;
    }
    if (dir === 'left') {
      for (let r = 0; r < size; r++) {
        let old = b[r].slice();
        let arr = b[r].filter(x => x);
        for (let i = 0; i < arr.length - 1; i++) {
          if (arr[i] === arr[i+1]) {
            arr[i] *= 2;
            this.score += arr[i];
            arr[i+1] = 0;
          }
        }
        arr = arr.filter(x => x);
        while (arr.length < size) arr.push(0);
        b[r] = arr;
        if (!moved && arr.join() !== old.join()) moved = true;
      }
    } else if (dir === 'right') {
      for (let r = 0; r < size; r++) {
        let old = b[r].slice();
        let arr = b[r].filter(x => x);
        for (let i = arr.length - 1; i > 0; i--) {
          if (arr[i] === arr[i-1]) {
            arr[i] *= 2;
            this.score += arr[i];
            arr[i-1] = 0;
          }
        }
        arr = arr.filter(x => x);
        while (arr.length < size) arr.unshift(0);
        b[r] = arr;
        if (!moved && arr.join() !== old.join()) moved = true;
      }
    } else if (dir === 'up') {
      for (let c = 0; c < size; c++) {
        let col = [];
        for (let r = 0; r < size; r++) col.push(b[r][c]);
        let old = col.slice();
        let arr = col.filter(x => x);
        for (let i = 0; i < arr.length - 1; i++) {
          if (arr[i] === arr[i+1]) {
            arr[i] *= 2;
            this.score += arr[i];
            arr[i+1] = 0;
          }
        }
        arr = arr.filter(x => x);
        while (arr.length < size) arr.push(0);
        for (let r = 0; r < size; r++) b[r][c] = arr[r];
        if (!moved && arr.join() !== old.join()) moved = true;
      }
    } else if (dir === 'down') {
      for (let c = 0; c < size; c++) {
        let col = [];
        for (let r = 0; r < size; r++) col.push(b[r][c]);
        let old = col.slice();
        let arr = col.filter(x => x);
        for (let i = arr.length - 1; i > 0; i--) {
          if (arr[i] === arr[i-1]) {
            arr[i] *= 2;
            this.score += arr[i];
            arr[i-1] = 0;
          }
        }
        arr = arr.filter(x => x);
        while (arr.length < size) arr.unshift(0);
        for (let r = 0; r < size; r++) b[r][c] = arr[r];
        if (!moved && arr.join() !== old.join()) moved = true;
      }
    }
    return moved;
  }
  isGameOver() {
    for (let r = 0; r < this.size; r++) for (let c = 0; c < this.size; c++) if (this.board[r][c] === 0) return false;
    // Check moves
    for (let r = 0; r < this.size; r++) for (let c = 0; c < this.size; c++) {
      if (r < this.size-1 && this.board[r][c] === this.board[r+1][c]) return false;
      if (c < this.size-1 && this.board[r][c] === this.board[r][c+1]) return false;
    }
    return true;
  }
  isGameWon() {
    for (let r = 0; r < this.size; r++) for (let c = 0; c < this.size; c++) if (this.board[r][c] === 2048) return true;
    return false;
  }
  showGameOver() {
    this.draw();
    const over = document.createElement('div');
    over.style.position = 'absolute';
    over.style.top = '50%';
    over.style.left = '50%';
    over.style.transform = 'translate(-50%,-50%)';
    over.style.background = 'rgba(0,0,0,0.85)';
    over.style.color = getGameAccent();
    over.style.fontSize = '2em';
    over.style.fontWeight = 'bold';
    over.style.padding = '32px 48px';
    over.style.borderRadius = '18px';
    over.style.boxShadow = '0 2px 16px #000a';
    over.style.zIndex = '10';
    over.innerHTML = 'Game Over!';
    this.boardDiv.parentNode.appendChild(over);
    setTimeout(() => { if (typeof this.onGameOver === 'function') this.onGameOver(); }, 1200);
  }
  showGameWon() {
    this.draw();
    const win = document.createElement('div');
    win.style.position = 'absolute';
    win.style.top = '50%';
    win.style.left = '50%';
    win.style.transform = 'translate(-50%,-50%)';
    win.style.background = 'rgba(0,0,0,0.85)';
    win.style.color = getGameAccent();
    win.style.fontSize = '2em';
    win.style.fontWeight = 'bold';
    win.style.padding = '32px 48px';
    win.style.borderRadius = '18px';
    win.style.boxShadow = '0 2px 16px #000a';
    win.style.zIndex = '10';
    win.innerHTML = 'You Win!';
    this.boardDiv.parentNode.appendChild(win);
  }
  updateTheme() {
    this.boardDiv.parentNode.style.background = getGameBg();
    this.boardDiv.parentNode.style.border = '4px solid ' + getGameAccent();
    this.scoreDiv.style.color = getGameInfo();
    this.draw();
  }
  draw() {
    // Remove all children
    while (this.boardDiv.firstChild) this.boardDiv.removeChild(this.boardDiv.firstChild);
    // Draw tiles
    for (let r = 0; r < this.size; r++) {
      for (let c = 0; c < this.size; c++) {
        const val = this.board[r][c];
        const tile = document.createElement('div');
        tile.style.display = 'flex';
        tile.style.alignItems = 'center';
        tile.style.justifyContent = 'center';
        tile.style.width = '100%';
        tile.style.height = '100%';
        tile.style.borderRadius = '8px';
        tile.style.fontWeight = 'bold';
        tile.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
        tile.style.fontSize = val < 128 ? '1.5em' : val < 1024 ? '1.2em' : '1em';
        tile.style.transition = 'all 0.2s';
        tile.style.background = get2048TileBg(val);
        tile.style.color = get2048TileColor(val);
        tile.textContent = val === 0 ? '' : val;
        this.boardDiv.appendChild(tile);
      }
    }
    this.scoreDiv.textContent = 'Score: ' + this.score;
  }
}

function get2048TileBg(val) {
  if (val === 0) return 'rgba(255,255,255,0.08)';
  const root = document.documentElement;
  const hacker = root.classList.contains('hacker-theme');
  if (hacker) {
    if (val === 2) return '#003b00';
    if (val === 4) return '#005500';
    if (val === 8) return '#007700';
    if (val === 16) return '#009900';
    if (val === 32) return '#00bb00';
    if (val === 64) return '#00dd00';
    if (val === 128) return '#22ff22';
    if (val === 256) return '#39ff14';
    if (val === 512) return '#7fffd4';
    if (val === 1024) return '#ffb86c';
    if (val === 2048) return '#fff';
    return '#222';
  }
  // dark/light
  if (val === 2) return '#eee4da';
  if (val === 4) return '#ede0c8';
  if (val === 8) return '#f2b179';
  if (val === 16) return '#f59563';
  if (val === 32) return '#f67c5f';
  if (val === 64) return '#f65e3b';
  if (val === 128) return '#edcf72';
  if (val === 256) return '#edcc61';
  if (val === 512) return '#edc850';
  if (val === 1024) return '#edc53f';
  if (val === 2048) return '#edc22e';
  return '#333';
}
function get2048TileColor(val) {
  if (val === 0) return 'rgba(0,0,0,0.18)';
  if (val <= 4) return '#222';
  if (val < 128) return '#fff';
  if (val < 1024) return '#fffbe7';
  if (val < 2048) return '#fff8c0';
  return '#000';
}

function startWhackAMoleGame() {
  window._whackAMoleActive = true;
  // Create overlay
  const overlay = document.createElement('div');
  overlay.id = 'whackamole-overlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.background = 'rgba(24,24,26,0.98)';
  overlay.style.display = 'flex';
  overlay.style.flexDirection = 'column';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.zIndex = '100';
  overlay.style.transition = 'opacity 0.4s';
  overlay.style.opacity = '1';
  // Responsive board container
  const boardWrap = document.createElement('div');
  boardWrap.style.display = 'flex';
  boardWrap.style.flexDirection = 'column';
  boardWrap.style.alignItems = 'center';
  boardWrap.style.justifyContent = 'center';
  boardWrap.style.width = 'min(90vw, 420px)';
  boardWrap.style.height = 'min(90vw, 480px)';
  boardWrap.style.maxWidth = '420px';
  boardWrap.style.maxHeight = '480px';
  boardWrap.style.background = getGameBg();
  boardWrap.style.border = '4px solid ' + getGameAccent();
  boardWrap.style.borderRadius = '18px';
  boardWrap.style.boxShadow = '0 4px 32px #000a, 0 0 0 2px ' + getGameBg();
  boardWrap.style.position = 'relative';
  // Score & Timer
  const infoDiv = document.createElement('div');
  infoDiv.id = 'whackamole-info';
  infoDiv.style.textAlign = 'center';
  infoDiv.style.color = getGameInfo();
  infoDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
  infoDiv.style.fontSize = '1.2em';
  infoDiv.style.marginBottom = '12px';
  infoDiv.innerHTML = 'Score: 0 | Time: 30s';
  // Message
  const msgDiv = document.createElement('div');
  msgDiv.style.textAlign = 'center';
  msgDiv.style.color = getGameAccent();
  msgDiv.style.fontFamily = 'Fira Mono, Consolas, Courier New, monospace';
  msgDiv.style.marginTop = '8px';
  msgDiv.innerHTML = 'Click/tap the moles! Type <b>stop</b> or press <b>Esc</b> to exit.';
  // Board
  const boardDiv = document.createElement('div');
  boardDiv.id = 'whackamole-board';
  boardDiv.style.width = 'min(80vw, 360px)';
  boardDiv.style.height = 'min(80vw, 360px)';
  boardDiv.style.maxWidth = '360px';
  boardDiv.style.maxHeight = '360px';
  boardDiv.style.display = 'grid';
  boardDiv.style.gridTemplateColumns = 'repeat(4, 1fr)';
  boardDiv.style.gridTemplateRows = 'repeat(4, 1fr)';
  boardDiv.style.gap = '18px';
  boardDiv.style.background = getGameBg();
  boardDiv.style.borderRadius = '12px';
  boardDiv.style.padding = '12px';
  // Add to overlay
  boardWrap.appendChild(infoDiv);
  boardWrap.appendChild(boardDiv);
  overlay.appendChild(boardWrap);
  overlay.appendChild(msgDiv);
  // Add overlay to terminal
  document.querySelector('.terminal-outer').appendChild(overlay);
  // Start game logic
  window._whackAMoleGame = new WhackAMoleGame(boardDiv, infoDiv, () => stopWhackAMoleGame(false));
  document.addEventListener('keydown', whackAMoleKeyHandler);
  window.addEventListener('themechange', updateWhackAMoleTheme);
}

function stopWhackAMoleGame(fromCommand) {
  window._whackAMoleActive = false;
  let lastScore = null;
  if (window._whackAMoleGame && typeof window._whackAMoleGame.stop === 'function') {
    if (window._whackAMoleGame.score !== undefined) lastScore = window._whackAMoleGame.score;
    window._whackAMoleGame.stop();
  }
  window._whackAMoleGame = null;
  const overlay = document.getElementById('whackamole-overlay');
  if (overlay) {
    overlay.style.opacity = '0';
    setTimeout(() => {
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
      terminalInput.value = '';
      terminalInput.focus();
      if (fromCommand) {
        printToTerminal('<span style="color:var(--ffb86c)">Exited Whack-a-Mole. Type <b>whack</b> to play again', true);
      }
      if (lastScore !== null) {
        let msg = `<span style=\"color:${getGameInfo()}\">Your score was <b>${lastScore}</b>!`;
        if (lastScore < 10) msg += " Keep practicing!";
        else if (lastScore < 25) msg += " Nice! Try for a higher score.";
        else msg += " Amazing reflexes!";
        msg += '</span>';
        printToTerminal(msg, true);
      }
    }, 400);
  }
  document.removeEventListener('keydown', whackAMoleKeyHandler);
  window.removeEventListener('themechange', updateWhackAMoleTheme);
}

function whackAMoleKeyHandler(e) {
  if (!window._whackAMoleActive) return;
  if (e.key === 'Escape') {
    stopWhackAMoleGame(true);
    return;
  }
}

function updateWhackAMoleTheme() {
  if (!window._whackAMoleActive || !window._whackAMoleGame) return;
  window._whackAMoleGame.updateTheme();
}

// Whack-a-Mole Game Implementation
class WhackAMoleGame {
  constructor(boardDiv, infoDiv, onGameOver) {
    this.boardDiv = boardDiv;
    this.infoDiv = infoDiv;
    this.onGameOver = onGameOver;
    this.size = 4;
    this.totalTiles = this.size * this.size;
    this.score = 0;
    this.time = 30;
    this.active = true;
    this.moleIndex = -1;
    this.timer = null;
    this.moleTimer = null;
    this.tiles = [];
    this.drawBoard();
    this.startGame();
  }
  stop() {
    this.active = false;
    clearInterval(this.timer);
    clearTimeout(this.moleTimer);
  }
  drawBoard() {
    while (this.boardDiv.firstChild) this.boardDiv.removeChild(this.boardDiv.firstChild);
    this.tiles = [];
    for (let i = 0; i < this.totalTiles; i++) {
      const tile = document.createElement('div');
      tile.style.display = 'flex';
      tile.style.alignItems = 'center';
      tile.style.justifyContent = 'center';
      tile.style.width = '100%';
      tile.style.height = '100%';
      tile.style.borderRadius = '50%';
      tile.style.background = getWhackTileBg();
      tile.style.transition = 'all 0.15s';
      tile.style.cursor = 'pointer';
      tile.style.position = 'relative';
      tile.addEventListener('click', () => this.whack(i));
      this.boardDiv.appendChild(tile);
      this.tiles.push(tile);
    }
  }
  startGame() {
    this.score = 0;
    this.time = 30;
    this.active = true;
    this.updateInfo();
    this.nextMole();
    this.timer = setInterval(() => {
      this.time--;
      this.updateInfo();
      if (this.time <= 0) {
        this.endGame();
      }
    }, 1000);
  }
  updateInfo() {
    this.infoDiv.innerHTML = `Score: ${this.score} | Time: ${this.time}s`;
  }
  nextMole() {
    if (!this.active) return;
    if (this.moleIndex !== -1) {
      this.tiles[this.moleIndex].innerHTML = '';
      this.tiles[this.moleIndex].style.background = getWhackTileBg();
    }
    this.moleIndex = Math.floor(Math.random() * this.totalTiles);
    const mole = document.createElement('div');
    mole.className = 'whack-mole';
    mole.style.width = '60%';
    mole.style.height = '60%';
    mole.style.borderRadius = '50%';
    mole.style.background = getWhackMoleColor();
    mole.style.boxShadow = '0 2px 8px #0006';
    mole.style.display = 'flex';
    mole.style.alignItems = 'center';
    mole.style.justifyContent = 'center';
    mole.style.fontSize = '2em';
    mole.style.color = '#fff';
    mole.innerHTML = '🐹';
    this.tiles[this.moleIndex].appendChild(mole);
    this.tiles[this.moleIndex].style.background = getWhackTileActiveBg();
    // Speed up as time decreases: from 1200ms to 400ms
    const minInterval = 400, maxInterval = 1200;
    const progress = 1 - (this.time / 30);
    const interval = Math.round(maxInterval - (maxInterval - minInterval) * progress);
    this.moleTimer = setTimeout(() => this.nextMole(), interval);
  }
  whack(i) {
    if (!this.active) return;
    if (i === this.moleIndex) {
      this.score++;
      this.tiles[i].innerHTML = '';
      this.tiles[i].style.background = getWhackTileBg();
      this.moleIndex = -1;
      clearTimeout(this.moleTimer);
      this.updateInfo();
      setTimeout(() => this.nextMole(), 200);
    }
  }
  endGame() {
    this.active = false;
    clearInterval(this.timer);
    clearTimeout(this.moleTimer);
    if (this.moleIndex !== -1) {
      this.tiles[this.moleIndex].innerHTML = '';
      this.tiles[this.moleIndex].style.background = getWhackTileBg();
    }
    setTimeout(() => { if (typeof this.onGameOver === 'function') this.onGameOver(); }, 1000);
  }
  updateTheme() {
    for (let i = 0; i < this.tiles.length; i++) {
      this.tiles[i].style.background = getWhackTileBg();
      if (i === this.moleIndex) this.tiles[i].style.background = getWhackTileActiveBg();
    }
  }
}
function getWhackTileBg() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) return '#111';
  return '#eee4da';
}
function getWhackTileActiveBg() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) return '#003b00';
  return '#f2b179';
}
function getWhackMoleColor() {
  const root = document.documentElement;
  if (root.classList.contains('hacker-theme')) return '#39ff14';
  return '#783286';
}

function updateSnakeTheme() {
  if (!snakeGameActive || !snakeGame) return;
  if (typeof snakeGame.updateTheme === 'function') snakeGame.updateTheme();
}

// Add a utility to forcefully clear all overlays and stop all games
function forceClearAllGames() {
  // Snake
  if (snakeGameActive) {
    if (snakeGame && typeof snakeGame.stop === 'function') snakeGame.stop();
    snakeGameActive = false;
    if (snakeOverlay && snakeOverlay.parentNode) snakeOverlay.parentNode.removeChild(snakeOverlay);
    snakeOverlay = null;
    window.removeEventListener('themechange', updateSnakeTheme);
    document.removeEventListener('keydown', snakeGameKeyHandler);
  }
  // Tetris
  if (tetrisGameActive) {
    if (tetrisGame && typeof tetrisGame.stop === 'function') tetrisGame.stop();
    tetrisGameActive = false;
    if (tetrisOverlay && tetrisOverlay.parentNode) tetrisOverlay.parentNode.removeChild(tetrisOverlay);
    tetrisOverlay = null;
    window.removeEventListener('themechange', updateTetrisTheme);
    document.removeEventListener('keydown', tetrisGameKeyHandler);
  }
  // 2048
  if (window._2048GameActive) {
    if (window._2048Game && typeof window._2048Game.stop === 'function') window._2048Game.stop();
    window._2048GameActive = false;
    const overlay = document.getElementById('game2048-overlay');
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    window.removeEventListener('themechange', update2048Theme);
    // No keydown for 2048
  }
  // Whack-a-Mole
  if (window._whackAMoleActive) {
    if (window._whackAMoleGame && typeof window._whackAMoleGame.stop === 'function') window._whackAMoleGame.stop();
    window._whackAMoleActive = false;
    const overlay = document.getElementById('whackamole-overlay');
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    window.removeEventListener('themechange', updateWhackAMoleTheme);
    // No keydown for whack
  }
}

// Add event delegation for the resume button and modal logic
if (typeof window !== 'undefined') {
  document.addEventListener('click', function(e) {
    if (e.target && e.target.id === 'view-resume-btn') {
      // Always open the Google Drive link in a new tab, on all platforms
      window.open('https://drive.google.com/file/d/1dZ-NJSqEC_-7WhmmMnoQrD6PuVJjmfcw/view?usp=sharing', '_blank');
      return;
    }
    if (e.target && e.target.id === 'close-resume-modal') {
      let modal = document.getElementById('resume-modal');
      if (modal) modal.remove();
    }
    if (e.target && e.target.id === 'view-paper-btn') {
      window.open('https://doi.org/10.56581/IJLRET.11.05.41-49', '_blank');
    }
  });
}
